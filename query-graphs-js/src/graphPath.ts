import {
  assert,
  Field,
  FragmentElement,
  InterfaceType,
  NamedType,
  OperationElement,
  Schema,
  SchemaRootKind,
  SelectionSet,
  typenameFieldName,
  isLeafType,
  baseType,
  CompositeType,
  isAbstractType,
  newDebugLogger,
  isCompositeType,
  parseFieldSetArgument,
  possibleRuntimeTypes,
  ObjectType,
  isObjectType,
  mapValues,
  federationMetadata,
  isSchemaRootType,
  Directive,
  FieldDefinition,
  printSubgraphNames,
  allFieldDefinitionsInSelectionSet,
  DeferDirectiveArgs,
} from "@apollo/federation-internals";
import { OpPathTree, traversePathTree } from "./pathTree";
import { Vertex, QueryGraph, Edge, RootVertex, isRootVertex, isFederatedGraphRootType, FEDERATED_GRAPH_ROOT_SOURCE } from "./querygraph";
import { Transition } from "./transition";
import { PathContext, emptyContext } from "./pathContext";

const debug = newDebugLogger('path');

function updateRuntimeTypes(currentRuntimeTypes: readonly ObjectType[], edge: Edge | null): readonly ObjectType[] {
  if (!edge) {
    return currentRuntimeTypes;
  }

  switch (edge.transition.kind) {
    case 'FieldCollection':
      const field = edge.transition.definition;
      if (!isCompositeType(baseType(field.type!))) {
        return [];
      }
      const newRuntimeTypes: ObjectType[] = [];
      for (const parentType of currentRuntimeTypes) {
        const fieldType = parentType.field(field.name)?.type;
        if (fieldType) {
          for (const type of possibleRuntimeTypes(baseType(fieldType) as CompositeType)) {
            if (!newRuntimeTypes.includes(type)) {
              newRuntimeTypes.push(type);
            }
          }
        }
      }
      return newRuntimeTypes;
    case 'DownCast':
      const castedType = edge.transition.castedType;
      const castedRuntimeTypes = possibleRuntimeTypes(castedType);
      return currentRuntimeTypes.filter(t => castedRuntimeTypes.includes(t));
    case 'KeyResolution':
      const currentType = edge.tail.type as CompositeType;
      // We've taken a key into a new subgraph, so any of the possible runtime types of the new subgraph could be returned.
      return possibleRuntimeTypes(currentType);
    case 'RootTypeResolution':
    case 'SubgraphEnteringTransition':
      assert(isObjectType(edge.tail.type), () => `Query edge should be between object type but got ${edge}`);
      return [ edge.tail.type ];
  }
}

function withReplacedLastElement<T>(arr: readonly T[], newLast: T): T[] {
  assert(arr.length > 0, 'Should not have been called on empty array');
  const newArr = new Array<T>(arr.length);
  for (let i = 0; i < arr.length - 1; i++) {
    newArr[i] = arr[i];
  }
  newArr[arr.length - 1] = newLast;
  return newArr;
}

/**
 * An immutable path in a query graph.
 *
 * Path is mostly understood in the graph theoretical sense of the term, that is as "a connected series of edges"
 * and a `GraphPath` is generated by traversing a graph query.
 * However, as query graph edges may have conditions, a `GraphPath` also records, for reach edges it is composed of,
 * the set of paths (an `OpPathTree` in practice) that were taken to fulfill the edge conditions (when the edge has
 * one).
 *
 * Additionally, for each edge of the path, a `GraphPath` records the "trigger" that made the traversal take that
 * edge. In practice, the "trigger" can be seen as a way to decorate a path with some additional metadata for each
 * elements of the path. In practice, that trigger is used in 2 main ways (corresponding to our 2 main query graph
 * traversals):
 *  - for composition validation, the traversal of the federated query graph is driven by other transitions into the
 *    supergraph API query graphs (essentially, composition validation is about finding, for every supergraph API
 *    query graph path, a "matching" traversal of the federated query graph). In that case, for the graph paths
 *    we build on the federated query graph, the "trigger" will be one of the `Transition` from the supergraph
 *    API graph (which, granted, will be fairly similar to the one of the edge we're taking in the federated query
 *    graph; in practice, triggers are more useful in the query planning case).
 *  - for query planning, the traversal of the federated query graph is driven by the elements of the query we are
 *    planning. Which means that the "trigger" for taking an edge in this case will be an `OperationElement`
 *    (or null). See the specialized `OpGraphPath` that is defined for this use case.
 *
 * Lastly, some `GraphPath` can actually encode "null" edges: this is used during query planning in the (rare)
 * case where the query we plan for has fragment spread without type condition (or a "useless" one, on that doesn't
 * restrict the possible types anymore than they already were) but with some directives. In that case, we want
 * to preserve the information about the directive (to properly rebuild query plans later) but it doesn't correspond
 * to taking any edges, so we add a "null" edge and use the trigger to store the fragment spread.
 *
 * @param TTrigger - the type of the paths "triggers", metadata that can associated to each element of the path (see
 *   above for more details).
 * @param RV - the type of the vertex starting the path. This simply default to `Vertex` but is used in `RootPath`/`OpRootPath`
 *   to easily distinguish those paths that starts from a root of a query graph.
 * @param TNullEdge - typing information to indicate whether the path can have "null" edges or not. Either `null` (
 *   meaning that the path may have null edges) or `never` (the path cannot have null edges).
 */
export class GraphPath<TTrigger, RV extends Vertex = Vertex, TNullEdge extends null | never = never> implements Iterable<[Edge | TNullEdge, TTrigger, OpPathTree | null]> {
  private constructor(
    /** The query graph of which this is a path. */
    readonly graph: QueryGraph,
    /** The vertex at which the path starts (the head vertex of the first edge in path, aliased here for convenience). */
    readonly root: RV,
    /** The vertex at which the path stops (the tail vertex of the last edge in path, aliased here for convenience). */
    readonly tail: Vertex,
    /** The triggers associated to each edges in the paths (see `GraphPath` for more details on triggers). */
    private readonly edgeTriggers: readonly TTrigger[],
    /** The edges (stored by edge index) composing the path. */
    private readonly edgeIndexes: readonly (number | TNullEdge)[],
    /**
     * For each edge in the path, if the edge has conditions, the set of paths that fulfill that condition.
     * Note that no matter which kind of traversal we are doing, fulfilling the conditions is always driven by
     * the conditions themselves, and as conditions are a graphQL result set, the resulting set of paths are
     * `OpGraphPath` (and as they are all rooted at the edge head vertex, we use the `OpPathTree` representation
     * for that set of paths).
     */
    private readonly edgeConditions: readonly (OpPathTree | null)[],

    private readonly subgraphEnteringEdgeIndex: number,
    readonly subgraphEnteringEdge: Edge | undefined,
    readonly subgraphEnteringEdgeCost: number,

    private readonly edgeToTail: Edge | TNullEdge | undefined,
    /** Names of the all the possible runtime types the tail of the path can be. */
    private readonly runtimeTypesOfTail: readonly ObjectType[],
    /** If the last edge (the one getting to tail) was a DownCast, the runtime types before that edge. */
    private readonly runtimeTypesBeforeTailIfLastIsCast?: readonly ObjectType[],

    readonly deferOnTail?: DeferDirectiveArgs,
  ) {
  }

  /**
   * Creates a new (empty) path starting at the provided vertex.
   */
  static create<TTrigger, RV extends Vertex = Vertex, TNullEdge extends null | never = never>(
    graph: QueryGraph,
    root: RV
  ): GraphPath<TTrigger, RV, TNullEdge> {
    // If 'graph' is a federated query graph, federation renames all root type to their default names, so we rely on this here.
    const runtimeTypes = isFederatedGraphRootType(root.type) ? [] : possibleRuntimeTypes(root.type as CompositeType);
    return new GraphPath(graph, root, root, [], [], [], -1, undefined, -1, undefined, runtimeTypes);
  }

  /**
   * Creates a new (empty) path starting from the root vertex in `graph` corresponding to the provide `rootKind`.
   */
  static fromGraphRoot<TTrigger, TNullEdge extends null | never = never>(
    graph: QueryGraph,
    rootKind: SchemaRootKind
  ): RootPath<TTrigger, TNullEdge> | undefined {
    const root = graph.root(rootKind);
    return root ? this.create(graph, root) : undefined;
  }

  /**
   * The size of the path, that is the number of edges composing it.
   *
   * Note that this only the "main" edges composing the path: some of those edges may have conditions for which the
   * path will also store the "sub-paths" necessary to fulfill said conditions, but the edges of those sub-paths are
   * _not_ counted here.
   */
  get size(): number {
    return this.edgeIndexes.length;
  }

  subgraphJumps(): number {
    let jumps = 0;
    let v: Vertex = this.root;
    for (let i = 0; i < this.size; i++) {
      const edge = this.edgeAt(i, v);
      if (!edge) {
        continue;
      }
      if (edge.transition.kind === 'KeyResolution' || edge.transition.kind === 'RootTypeResolution') {
        ++jumps;
      }
      v = edge.tail;
    }
    return jumps;
  }

  [Symbol.iterator](): PathIterator<TTrigger, TNullEdge> {
    const path = this;
    return {
      currentIndex: 0,
      currentVertex: this.root,
      next(): IteratorResult<[Edge | TNullEdge, TTrigger, OpPathTree | null]> {
        if (this.currentIndex >= path.size) {
          return { done: true, value: undefined };
        }
        const idx = this.currentIndex++;
        const edge = path.edgeAt(idx, this.currentVertex);
        if (edge) {
          this.currentVertex = edge.tail;
        }
        return { done: false, value: [edge, path.edgeTriggers[idx], path.edgeConditions[idx]] };
      }
    };
  }

  /**
   * The last edge in the path (if it isn't empty).
   */
  lastEdge(): Edge | TNullEdge | undefined {
    return this.edgeToTail;
  }

  lastTrigger(): TTrigger | undefined {
    return this.edgeTriggers[this.size - 1];
  }

  tailPossibleRuntimeTypes(): readonly ObjectType[] {
    return this.runtimeTypesOfTail;
  }

  /**
   * Creates the new path corresponding to appending to this path the provided `edge`.
   *
   * @param trigger - the trigger for taking the edge in the created path.
   * @param edge - the edge to add (which may be 'null' if this type of path allows it, but if it isn't should be an out-edge
   *   for `s.tail`).
   * @param conditionsResolution - the result of resolving the conditions for this edge.
   * @param defer - if the trigger is an operation with a @defer on it, the arguments of this @defer.
   * @returns the newly created path.
   */
  add(trigger: TTrigger, edge: Edge | TNullEdge, conditionsResolution: ConditionResolution, defer?: DeferDirectiveArgs): GraphPath<TTrigger, RV, TNullEdge> {
    assert(!edge || this.tail.index === edge.head.index, () => `Cannot add edge ${edge} to path ending at ${this.tail}`);
    assert(conditionsResolution.satisfied, 'Should add to a path if the conditions cannot be satisfied');
    assert(!edge || edge.conditions || !conditionsResolution.pathTree, () => `Shouldn't have conditions paths (got ${conditionsResolution.pathTree}) for edge without conditions (edge: ${edge})`);

    if (edge && edge.transition.kind === 'DownCast' && this.edgeToTail) {
      const previousOperation = this.lastTrigger();
      if (previousOperation instanceof FragmentElement && previousOperation.appliedDirectives.length === 0) {
        // This mean we have 2 type-cast back-to-back and that means the previous operation might not be
        // useful on this path. More precisely, the previous type-cast was only useful if it restricted
        // the possible runtime types of the type on which it applied more than the current type-cast
        // does (but note that if the previous type-cast had directives, we keep it not matter what in
        // case those directives are important).
        // That is, we're in the where we have (somewhere potentially deep in a query):
        //   f {  # field 'f' of type A
        //     ... on B {
        //       ... on C {
        //          # more stuffs
        //       }
        //     }
        //   }
        // If the intersection of A and C is non empty and included (or equal) to the intersection of A and B,
        // then there is no reason to have `... on B` at all because:
        //  1. you can do `... on C` on `f` directly since the intersection of A and C is non-empty.
        //  2. `... on C` restricts strictly more than `... on B` and so the latter can't impact the result.
        // So if we detect that we're in that situation, we remove the `... on B` (but note that this is an
        // optimization, keeping `... on B` wouldn't be incorrect, just useless).
        const runtimeTypesWithoutPreviousCast = updateRuntimeTypes(this.runtimeTypesBeforeTailIfLastIsCast!, edge);
        if (runtimeTypesWithoutPreviousCast.length > 0
          && runtimeTypesWithoutPreviousCast.every(t => this.runtimeTypesOfTail.includes(t))
        ) {
          // Note that edge is from the vertex we've eliminating from the path. So we need to get the edge goes
          // directly from the prior vertex to the new tail for that path.
          const updatedEdge = this.graph.outEdges(this.edgeToTail!.head).find(e => e.tail.type === edge.tail.type);
          if (updatedEdge) {
            // We replace the previous operation by the new one.
            debug.log(() => `Previous cast ${previousOperation} is made obsolete by new cast ${trigger}, removing from path.`);
            return new GraphPath(
              this.graph,
              this.root,
              updatedEdge.tail,
              withReplacedLastElement(this.edgeTriggers, trigger),
              withReplacedLastElement(this.edgeIndexes, updatedEdge.index),
              withReplacedLastElement(this.edgeConditions, conditionsResolution.pathTree ?? null),
              this.subgraphEnteringEdgeIndex,
              this.subgraphEnteringEdge,
              this.subgraphEnteringEdgeCost,
              updatedEdge,
              runtimeTypesWithoutPreviousCast,
              this.runtimeTypesBeforeTailIfLastIsCast, // Note that those haven't changed, and last is still a cast
              defer,
            );
          }
        }
      }
    }

    let subgraphEnteringEdgeIndex = this.subgraphEnteringEdgeIndex;
    let subgraphEnteringEdge = this.subgraphEnteringEdge;
    let subgraphEnteringEdgeCost = this.subgraphEnteringEdgeCost;
    if (edge) {
      // `subgraphEnteringEdge` is used to be able to eliminate some options when we can detect that going to subgraph
      // was ineffectient (see `advancePathWithNonCollectingAndTypePreservingTransitions` for details). So first,
      // we shouldn't change it for a "key to self" due to a @defer since the assumption of `subgraphEnteringEdge` is
      // that the source is different from the destination. But really, if we use `@defer`, we should never rely on the
      // optimization that `subgraphEnteringEdge`, so we clear it entirely.
      if (edge.isKeyOrRootTypeEdgeToSelf()) {
        subgraphEnteringEdgeIndex = -1;
        subgraphEnteringEdge = undefined;
        subgraphEnteringEdgeCost = -1;
      } else if (edge.transition.kind === 'KeyResolution') {
        subgraphEnteringEdgeIndex = this.size;
        subgraphEnteringEdge = edge;
        subgraphEnteringEdgeCost = conditionsResolution.cost;
      }
    }

    return new GraphPath(
      this.graph,
      this.root,
      edge ? edge.tail : this.tail,
      this.edgeTriggers.concat(trigger),
      this.edgeIndexes.concat((edge ? edge.index : null) as number | TNullEdge),
      this.edgeConditions.concat(conditionsResolution.pathTree ?? null),
      subgraphEnteringEdgeIndex,
      subgraphEnteringEdge,
      subgraphEnteringEdgeCost,
      edge,
      updateRuntimeTypes(this.runtimeTypesOfTail, edge),
      edge?.transition?.kind === 'DownCast' ? this.runtimeTypesOfTail : undefined,
      defer,
    );
  }

  /**
   * Creates a new path corresponding to concatenating the provide path _after_ this path.
   *
   * @param tailPath - the path to concatenate at the end of this path. That path must start on the vertex at which
   *   this path ends.
   * @returns the newly created path.
   */
  concat(tailPath: GraphPath<TTrigger, Vertex, TNullEdge>): GraphPath<TTrigger, RV, TNullEdge> {
    assert(this.tail.index === tailPath.root.index, () => `Cannot concat ${tailPath} after ${this}`);
    if (tailPath.size === 0) {
      return this;
    }

    let prevRuntimeTypes = this.runtimeTypesBeforeTailIfLastIsCast;
    let runtimeTypes = this.runtimeTypesOfTail;
    for (const [edge] of tailPath) {
      prevRuntimeTypes = runtimeTypes;
      runtimeTypes = updateRuntimeTypes(runtimeTypes, edge);
    }
    return new GraphPath(
      this.graph,
      this.root,
      tailPath.tail,
      this.edgeTriggers.concat(tailPath.edgeTriggers),
      this.edgeIndexes.concat(tailPath.edgeIndexes),
      this.edgeConditions.concat(tailPath.edgeConditions),
      tailPath.subgraphEnteringEdge ? tailPath.subgraphEnteringEdgeIndex : this.subgraphEnteringEdgeIndex,
      tailPath.subgraphEnteringEdge ? tailPath.subgraphEnteringEdge : this.subgraphEnteringEdge,
      tailPath.subgraphEnteringEdge ? tailPath.subgraphEnteringEdgeCost : this.subgraphEnteringEdgeCost,
      tailPath.edgeToTail,
      runtimeTypes,
      tailPath.edgeToTail?.transition?.kind === 'DownCast' ? prevRuntimeTypes : undefined
    );
  }

  checkDirectPathFomPreviousSubgraphTo(
    typeName: string,
    triggerToEdge: (graph: QueryGraph, vertex: Vertex, t: TTrigger) => Edge | null | undefined
  ): Vertex | undefined {
    if (this.subgraphEnteringEdgeIndex < 0) {
      return undefined;
    }
    assert(this.subgraphEnteringEdge, 'Should have an entering edge since the index is >= 0');
    let prevSubgraphVertex = this.subgraphEnteringEdge.head;
    for (let i = this.subgraphEnteringEdgeIndex + 1; i < this.size; i++) {
      const triggerToMatch = this.edgeTriggers[i];
      const prevSubgraphMatchingEdge = triggerToEdge(this.graph, prevSubgraphVertex, triggerToMatch);
      if (prevSubgraphMatchingEdge === null) {
        // This means the trigger doesn't make us move (it's typically an inline fragment with no conditions, just directive), which we can always match.
        continue;
      }
      // If the edge has conditions, we don't consider it a direct path as we don't know if that condition can be satisfied and at what cost.
      if (!prevSubgraphMatchingEdge || prevSubgraphMatchingEdge.conditions) {
        return undefined;
      }
      prevSubgraphVertex = prevSubgraphMatchingEdge.tail;
    }
    // If we got here, that mean we were able to match all the triggers from the path since we switched from the previous graph directly into
    // the previous graph, and so, assuming we're on the proper type, we have a direct path in that previous graph.
    return prevSubgraphVertex.type.name === typeName ? prevSubgraphVertex : undefined;
  }

  /**
   * The set of edges that may legally continue this path.
   */
  nextEdges(): readonly Edge[] {
    if (this.deferOnTail) {
      // If we path enters a @defer (meaning that what comes after needs to be deferred), then it's the one special case where we
      // explicitly need to ask for edges-to-self, as we _will_ force the use of a @key edge (so we can send the non-deferred part
      // immediately) and we may have to resume the deferred part in the same subgraph than the one in which we were (hence the need
      // for edges to self).
      return this.graph.outEdges(this.tail, true);
    }

    // In theory, we could always return `this.graph.outEdges(this.tail)` here. But in practice, `nonTrivialFollowupEdges` may give us a subset
    // of those "out edges" that avoids some of the edges that we know we don't need to check because they are guaranteed to be inefficient
    // after the previous `tailEdge`. Note that is purely an optimization (see https://github.com/apollographql/federation/pull/1653 for more details).
    const tailEdge = this.edgeToTail;
    return tailEdge
      ? this.graph.nonTrivialFollowupEdges(tailEdge)
      : this.graph.outEdges(this.tail);
  }

  /**
   * Whether the path is terminal, that is ends on a terminal vertex.
   */
  isTerminal() {
    return this.graph.isTerminal(this.tail);
  }

  /**
   * Whether this path is a `RootPath`, that is one whose starting vertex is one of the underlying query graph root.
   */
  isRootPath(): this is RootPath<TTrigger, TNullEdge> {
    return isRootVertex(this.root);
  }

  mapMainPath<T>(mapper: (e: Edge | TNullEdge, pathIdx: number) => T): T[] {
    const result = new Array(this.size);
    let v: Vertex = this.root;
    for (let i = 0; i < this.size; i++) {
      const edge = this.edgeAt(i, v);
      result[i] = mapper(edge, i);
      if (edge) {
        v = edge.tail;
      }
    }
    return result;
  }

  private edgeAt(index: number, v: Vertex): Edge | TNullEdge {
    const edgeIdx = this.edgeIndexes[index];
    return (edgeIdx !== null ? this.graph.outEdge(v, edgeIdx) : null) as Edge | TNullEdge;
  }

  reduceMainPath<T>(reducer: (accumulator: T, edge: Edge | TNullEdge, pathIdx: number) => T, initialValue: T): T {
    let value = initialValue;
    let v: Vertex = this.root;
    for (let i = 0; i < this.size; i++) {
      const edge = this.edgeAt(i, v);
      value = reducer(value, edge, i);
      if (edge) {
        v = edge.tail;
      }
    }
    return value;
  }

  /**
   * Whether the path forms a cycle on the its end vertex, that is if the end vertex of this path has already been encountered earlier in the path.
   */
  hasJustCycled(): boolean {
    if (this.root.index == this.tail.index) {
      return true;
    }
    let v: Vertex = this.root;
    // We ignore the last edge since it's the one leading to the current vertex.
    for (let i = 0; i < this.size - 1; i++) {
      const edge = this.edgeAt(i, v);
      if (!edge) {
        continue;
      }
      v = edge.tail;
      if (v.index == this.tail.index) {
        return true;
      }
    }
    return false;
  }

  /**
   * Whether any of the edge in the path has associated conditions paths.
   */
  hasAnyEdgeConditions(): boolean {
    return this.edgeConditions.some(c => c !== null);
  }

  isOnTopLevelQueryRoot(): boolean {
    if (!isRootVertex(this.root)) {
      return false;
    }
    // We walk the vertices and as soon as we take a field (or move out of the root type),
    // we know we're not on the top-level query/mutation/subscription root anymore. The reason we don't
    // just check that size <= 1 is that we could have top-level `... on Query`
    // conditions that don't actually move us.
    let vertex: Vertex = this.root;
    for (let i = 0; i < this.size; i++) {
      const edge = this.edgeAt(i, vertex);
      if (!edge) {
        continue;
      }
      if (edge.transition.kind === 'FieldCollection' || !isSchemaRootType(edge.tail.type)) {
        return false;
      }
      vertex = edge.tail;
    }
    return true;
  }

  truncateTrailingDowncasts(): GraphPath<TTrigger, RV, TNullEdge> {
    let lastNonDowncastIdx = -1;
    let v: Vertex = this.root;
    let lastNonDowncastVertex = v;
    let lastNonDowncastEdge: Edge | undefined;
    let runtimeTypes = isFederatedGraphRootType(this.root.type) ? [] : possibleRuntimeTypes(this.root.type as CompositeType);
    let runtimeTypesAtLastNonDowncastEdge = runtimeTypes;
    for (let i = 0; i < this.size; i++) {
      const edge = this.edgeAt(i, v);
      runtimeTypes = updateRuntimeTypes(runtimeTypes, edge);
      if (edge) {
        v = edge.tail;
        if (edge.transition.kind !== 'DownCast') {
          lastNonDowncastIdx = i;
          lastNonDowncastVertex = v;
          lastNonDowncastEdge = edge;
          runtimeTypesAtLastNonDowncastEdge = runtimeTypes;
        }
      }
    }
    if (lastNonDowncastIdx < 0 || lastNonDowncastIdx === this.size -1) {
      return this;
    }

    const newSize = lastNonDowncastIdx + 1;
    return new GraphPath(
      this.graph,
      this.root,
      lastNonDowncastVertex,
      this.edgeTriggers.slice(0, newSize),
      this.edgeIndexes.slice(0, newSize),
      this.edgeConditions.slice(0, newSize),
      // Note as we _only_ truncate downCast edges, the "subgraph entering edge" cannot have changed.
      this.subgraphEnteringEdgeIndex,
      this.subgraphEnteringEdge,
      this.subgraphEnteringEdgeCost,
      lastNonDowncastEdge,
      runtimeTypesAtLastNonDowncastEdge
    );
  }

  toString(): string {
    const isRoot = isRootVertex(this.root);
    if (isRoot && this.size === 0) {
      return '_';
    }
    const pathStr = this.mapMainPath((edge, idx) => {
      if (edge) {
        if (isRoot && idx == 0) {
          return edge.tail.toString();
        }
        const label = edge.label();
        return ` -${label === "" ? "" : '-[' + label + ']-'}-> ${edge.tail}`
      }
      return ` (${this.edgeTriggers[idx]}) `;
    }).join('');
    const deferStr = this.deferOnTail ? ` <defer='${this.deferOnTail.label}'>` : '';
    return `${isRoot ? '' : this.root}${pathStr}${deferStr} (types: [${this.runtimeTypesOfTail.join(', ')}])`;
  }
}

export interface PathIterator<TTrigger, TNullEdge extends null | never = never> extends Iterator<[Edge | TNullEdge, TTrigger, OpPathTree | null]> {
  currentIndex: number,
  currentVertex: Vertex
}

/**
 * A `GraphPath` that starts on a vertex that is a root vertex (of the query graph of which this is a path).
 */
export type RootPath<TTrigger, TNullEdge extends null | never = never> = GraphPath<TTrigger, RootVertex, TNullEdge>;

export type OpTrigger = OperationElement | PathContext;

/**
 * A `GraphPath` whose triggers are `OperationElement` (essentially meaning that the path has been guided by a graphQL query).
 */
export type OpGraphPath<RV extends Vertex = Vertex> = GraphPath<OpTrigger, RV, null>;

/**
 * An `OpGraphPath` that starts on a vertex that is a root vertex (of the query graph of which this is a path).
 */
export type OpRootPath = OpGraphPath<RootVertex>;

export function isRootPath(path: OpGraphPath<any>): path is OpRootPath {
  return isRootVertex(path.root);
}

export function terminateWithNonRequestedTypenameField<V extends Vertex>(path: OpGraphPath<V>): OpGraphPath<V> {
  // If the last step of the path was a fragment/type-condition, we want to remove it before we get __typename.
  // The reason is that this avoid cases where this method would make us build plans like:
  // {
  //   foo {
  //     __typename
  //     ... on A {
  //       __typename
  //     }
  //     ... on B {
  //       __typename
  //     }
  // }
  // Instead, we just generate:
  // {
  //   foo {
  //     __typename
  //   }
  // }
  // Note it's ok to do this because the __typename we add is _not_ requested, it is just added in cases where we
  // need to ensure a selection is not empty, and so this transformation is fine to do.
  path = path.truncateTrailingDowncasts();
  if (!isCompositeType(path.tail.type)) {
    return path;
  }
  const typenameField = new Field(path.tail.type.typenameField()!);
  const edge = edgeForField(path.graph, path.tail, typenameField);
  assert(edge, () => `We should have an edge from ${path.tail} for ${typenameField}`);
  return path.add(typenameField, edge, noConditionsResolution);
}

export function traversePath(
  path: GraphPath<any>,
  onEdges: (edge: Edge) => void
){
  for (const [edge, _, conditions] of path) {
    if (conditions) {
      traversePathTree(conditions, onEdges);
    }
    onEdges(edge);
  }
}

// Note that ConditionResolver are guaranteed to be only called for edge with conditions.
export type ConditionResolver =
  (edge: Edge, context: PathContext, excludedEdges: ExcludedEdges, excludedConditions: ExcludedConditions) => ConditionResolution;


export type ConditionResolution = {
  satisfied: boolean,
  cost: number,
  pathTree?: OpPathTree
  // Note that this is not guaranteed to be set even if satistied === false.
  unsatisfiedConditionReason?: UnsatisfiedConditionReason
}

export enum UnsatisfiedConditionReason {
  NO_POST_REQUIRE_KEY
}

export const noConditionsResolution: ConditionResolution = { satisfied: true, cost: 0 };
export const unsatisfiedConditionsResolution: ConditionResolution = { satisfied: false, cost: -1 };

export enum UnadvanceableReason {
  UNSATISFIABLE_KEY_CONDITION,
  UNSATISFIABLE_REQUIRES_CONDITION,
  NO_MATCHING_TRANSITION,
  UNREACHABLE_TYPE,
  IGNORED_INDIRECT_PATH
}

export type Unadvanceable = {
  sourceSubgraph: string,
  destSubgraph: string,
  reason: UnadvanceableReason,
  details: string
};

export class Unadvanceables {
  constructor(readonly reasons: Unadvanceable[]) {}

  toString() {
    return '[' + this.reasons.map((r) => `[${r.reason}](${r.sourceSubgraph}->${r.destSubgraph}) ${r.details}`).join(', ') + ']';
  }
}

export function isUnadvanceable(result: any[] | Unadvanceables): result is Unadvanceables {
  return result instanceof Unadvanceables;
}

function pathTransitionToEdge(graph: QueryGraph, vertex: Vertex, transition: Transition): Edge | null | undefined {
  for (const edge of graph.outEdges(vertex)) {
    // The edge must match the transition.
    if (edge.matchesSupergraphTransition(transition)) {
      return edge;
    }
  }
  return undefined;
}

/**
 * Wraps a 'composition validation' path (one built from `Transition`) along with the information necessary to compute
 * the indirect paths following that path, and cache the result of that computation when triggered.
 *
 * In other words, this is a `GraphPath<Transition, V>` plus lazy memoization of the computation of its following indirect
 * options.
 *
 * The rational is that after we've reached a given path, we might never need to compute the indirect paths following it
 * (maybe all the fields we'll care about are available "directive" (from the same subgraph)), or we might need to compute
 * it once, or we might need them multiple times, but the way the algorithm work, we don't know this in advance. So
 * this abstraction ensure that we only compute such indirect paths lazily, if we ever need them, but while ensuring
 * we don't recompute them multiple times if we do need them multiple times.
 */
export class TransitionPathWithLazyIndirectPaths<V extends Vertex = Vertex> {
  private lazilyComputedIndirectPaths: IndirectPaths<Transition, V> | undefined;

  constructor(
    readonly path: GraphPath<Transition, V>,
    readonly conditionResolver: ConditionResolver,
  ) {
  }

  static initial<V extends Vertex = Vertex>(
    initialPath: GraphPath<Transition, V>,
    conditionResolver: ConditionResolver,
  ): TransitionPathWithLazyIndirectPaths<V> {
    return new TransitionPathWithLazyIndirectPaths(initialPath, conditionResolver);
  }

  indirectOptions(): IndirectPaths<Transition, V> {
    if (!this.lazilyComputedIndirectPaths) {
      this.lazilyComputedIndirectPaths = this.computeIndirectPaths();
    }
    return this.lazilyComputedIndirectPaths;
  }

  private computeIndirectPaths(): IndirectPaths<Transition, V>  {
    return advancePathWithNonCollectingAndTypePreservingTransitions(
      this.path,
      emptyContext,
      this.conditionResolver,
      [],
      [],
      (t) => t,
      pathTransitionToEdge,
    );
  }

  toString(): string {
    return this.path.toString();
  }
}

// Note: conditions resolver should return `null` if the condition cannot be satisfied. If it is satisfied, it has the choice of computing
// the actual tree, which we need for query planning, or simply returning "undefined" which means "The condition can be satisfied but I didn't
// bother computing a tree for it", which we use for simple validation.

// Returns undefined if there is no way to advance the path with this transition. Otherwise, it returns a list of options (paths) we can be in after advancing the transition.
// The lists of options can be empty, which has the special meaning that the transition is guaranteed to have no results (it corresponds to unsatisfiable conditions),
// meaning that as far as composition validation goes, we can ignore that transition (and anything that follows) and otherwise continue.
export function advancePathWithTransition<V extends Vertex>(
  subgraphPath: TransitionPathWithLazyIndirectPaths<V>,
  transition: Transition,
  targetType: NamedType,
) : TransitionPathWithLazyIndirectPaths<V>[] | Unadvanceables {
  // The `transition` comes from the supergraph. Now, it is possible that a transition can be expressed on the supergraph, but correspond
  // to an 'unsatisfiable' condition on the subgraph. Let's consider:
  // - Subgraph A:
  //    type Query {
  //       get: [I]
  //    }
  //
  //    interface I {
  //      k: Int
  //    }
  //
  //    type T1 implements I @key(fields: "k") {
  //      k: Int
  //      a: String
  //    }
  //
  //    type T2 implements I @key(fields: "k") {
  //      k: Int
  //      b: String
  //    }
  //
  // - Subgraph B:
  //    interface I {
  //      k: Int
  //    }
  //
  //    type T1 implements I @key(fields: "k") {
  //      k: Int
  //      myself: I
  //    }
  //
  // On the resulting supergraph, we will have a path for:
  //   {
  //     get {
  //       ... on T1 {
  //         myself {
  //           ... on T2 {
  //             b
  //           }
  //         }
  //       }
  //     }
  //   }
  //
  // However, as we compute possible subgraph paths, the `myself` field will get us
  // in subgraph `B` through `T1`'s key. But then, as we look at transition `... on T2`
  // from subgraph `B`, we have no such type/transition. But this does not mean that
  // the subgraphs shouldn't compose. What it really means is that the corresponding
  // query above can be done, but is guaranteed to never return anything (essentially,
  // we can query subgraph 'B' but will never get a `T2` so the result of the query
  // should be empty).
  //
  // So we need to handle this case and we do this first. Note that the only kind of
  // transition that can give use this is a 'DownCast' transition.
  if (transition.kind === 'DownCast') {
    // If we consider a 'downcast' transition, it means that the target of that cast is composite, but also that the
    // last type of the subgraph path also is (that type is essentially the "source" of the cast).
    const supergraphRuntimeTypes = possibleRuntimeTypes(targetType as CompositeType);
    const subgraphRuntimeTypes = subgraphPath.path.tailPossibleRuntimeTypes();
    const intersection = supergraphRuntimeTypes.filter(t1 => subgraphRuntimeTypes.some(t2 => t1.name === t2.name)).map(t => t.name);
    // if we intersection is empty, it means whatever field got us here can never resolve into an object of the type we're casting
    // into. Essentially, we're good building a plan for this transition and whatever comes next: it'll just return nothing.
    if (intersection.length === 0) {
      debug.log(() => `No intersection between casted type ${targetType} and the possible types in this subgraph`);
      return [];
    }
  }

  debug.group(() => `Trying to advance ${subgraphPath} for ${transition}`);
  debug.group('Direct options:');
  const directOptions = advancePathWithDirectTransition(subgraphPath.path, transition, subgraphPath.conditionResolver);
  let options: GraphPath<Transition, V>[];
  const deadEnds: Unadvanceable[] = [];
  if (isUnadvanceable(directOptions)) {
    options = [];
    debug.groupEnd(() => 'No direct options');
    deadEnds.push(...directOptions.reasons);
  } else {
    debug.groupEnd(() => advanceOptionsToString(directOptions));
    // If we can fulfill the transition directly (without taking an edge) and the target type is "terminal", then there is
    // no point in computing all the options.
    if (directOptions.length > 0 && isLeafType(targetType)) {
      debug.groupEnd(() => `reached leaf type ${targetType} so not trying indirect paths`);
      return createLazyTransitionOptions(directOptions, subgraphPath);
    }
    options = directOptions;
  }
  // Otherwise, let's try non-collecting edges and see if we can find some (more) options there.
  debug.group(`Computing indirect paths:`);
  const pathsWithNonCollecting = subgraphPath.indirectOptions();
  if (pathsWithNonCollecting.paths.length > 0) {
    debug.groupEnd(() => `${pathsWithNonCollecting.paths.length} indirect paths`);
    debug.group('Validating indirect options:');
    for (const nonCollectingPath of pathsWithNonCollecting.paths) {
      debug.group(() => `For indirect path ${nonCollectingPath}:`);
      const pathsWithTransition = advancePathWithDirectTransition(nonCollectingPath, transition, subgraphPath.conditionResolver);
      if (isUnadvanceable(pathsWithTransition)) {
        debug.groupEnd(() => `Cannot be advanced with ${transition}`);
        deadEnds.push(...pathsWithTransition.reasons);
      } else {
        debug.groupEnd(() => `Adding valid option: ${pathsWithTransition}`);
        options = options.concat(pathsWithTransition);
      }
    }
    debug.groupEnd();
  } else {
    debug.groupEnd('no indirect paths');
  }
  debug.groupEnd(() => options.length > 0 ? advanceOptionsToString(options) : `Cannot advance ${transition} for this path`);
  if (options.length > 0) {
    return createLazyTransitionOptions(options, subgraphPath);
  }

  const allDeadEnds = deadEnds.concat(pathsWithNonCollecting.deadEnds.reasons);
  if (transition.kind === 'FieldCollection') {
    const typeName = transition.definition.parent.name;
    const fieldName = transition.definition.name;
    const subgraphsWithDeadEnd = new Set(allDeadEnds.map(e => e.destSubgraph));
    for (const [subgraph, schema] of subgraphPath.path.graph.sources.entries()) {
      if (subgraphsWithDeadEnd.has(subgraph)) {
        continue;
      }
      const type = schema.type(typeName);
      if (type && isCompositeType(type) && type.field(fieldName)) {
        // That subgraph has the type we look for, but we have recorded no dead-ends. This means there is no edge to that type,
        // and thus that it has no keys.
        const metadata = federationMetadata(schema);
        const keys: Directive<CompositeType, {fields: any, resolvable?: boolean}>[] = metadata ? type.appliedDirectivesOf(metadata.keyDirective()) : [];
        const allNonResolvable = keys.length > 0 && keys.every((k) => !(k.arguments().resolvable ?? true));
        assert(keys.length === 0 || allNonResolvable, () => `Expected type ${type} in ${subgraph} to have no resolvable keys`);
        const explanation = keys.length === 0
          ? `type "${typeName}" has no @key defined in subgraph "${subgraph}"`
          : `none of the @key defined on type "${typeName}" in subgraph "${subgraph}" are resolvable (they are all declared with their "resolvable" argument set to false)`;
        allDeadEnds.push({
          sourceSubgraph: subgraphPath.path.tail.source,
          destSubgraph: subgraph,
          reason: UnadvanceableReason.UNREACHABLE_TYPE,
          details: `cannot move to subgraph "${subgraph}", which has field "${transition.definition.coordinate}", because ${explanation}`
        });
      }
    }
  }

  return new Unadvanceables(allDeadEnds);
}

function createLazyTransitionOptions<V extends Vertex>(
  options: GraphPath<Transition, V>[],
  origin: TransitionPathWithLazyIndirectPaths<V>,
) : TransitionPathWithLazyIndirectPaths<V>[] {
  return options.map(option => new TransitionPathWithLazyIndirectPaths(
    option,
    origin.conditionResolver,
  ));
}

// A set of excluded edges, that is a pair of a head vertex index and an edge index (since edge indexes are relative to their vertex).
export type ExcludedEdges = readonly [number, number][];

function isEdgeExcluded(edge: Edge, excluded: ExcludedEdges): boolean {
  return excluded.some(([vIdx, eIdx]) => edge.head.index === vIdx && edge.index === eIdx);
}

export function sameExcludedEdges(ex1: ExcludedEdges, ex2: ExcludedEdges): boolean {
  if (ex1 === ex2) {
    return true;
  }
  if (ex1.length !== ex2.length) {
    return false;
  }
  for (let i = 0; i < ex1.length; ++i) {
    if (ex1[i][0] !== ex2[i][0] || ex1[i][1] !== ex2[i][1]) {
      return false;
    }
  }
  return true;
}

function addEdgeExclusion(excluded: ExcludedEdges, newExclusion: Edge): ExcludedEdges {
  return excluded.concat([[newExclusion.head.index, newExclusion.index]]);
}

export type ExcludedConditions = readonly SelectionSet[];

function isConditionExcluded(condition: SelectionSet | undefined, excluded: ExcludedConditions): boolean {
  if (!condition) {
    return false;
  }
  return excluded.find(e => condition.equals(e)) !== undefined;
}

export function addConditionExclusion(excluded: ExcludedConditions, newExclusion: SelectionSet | undefined): ExcludedConditions {
  return newExclusion ? excluded.concat(newExclusion) : excluded;
}

function popMin<TTrigger, V extends Vertex, TNullEdge extends null | never = never>(
  stack: GraphPath<TTrigger, V, TNullEdge>[]
): GraphPath<TTrigger, V, TNullEdge> {
  let minIdx = 0;
  let minSize = stack[0].size;
  for (let i = 1; i < stack.length; i++) {
    if (stack[i].size < minSize) {
      minSize = stack[i].size;
      minIdx = i;
    }
  }
  const min = stack[minIdx];
  stack.splice(minIdx, 1);
  return min;
}

export type IndirectPaths<TTrigger, V extends Vertex = Vertex, TNullEdge extends null | never = never, TDeadEnds extends Unadvanceables | never = Unadvanceables> = {
  paths: GraphPath<TTrigger, V, TNullEdge>[],
  deadEnds: TDeadEnds
}

function advancePathWithNonCollectingAndTypePreservingTransitions<TTrigger, V extends Vertex, TNullEdge extends null | never = never, TDeadEnds extends Unadvanceables | never = Unadvanceables>(
  path: GraphPath<TTrigger, V, TNullEdge>,
  context: PathContext,
  conditionResolver: ConditionResolver,
  excludedEdges: ExcludedEdges,
  excludedConditions: ExcludedConditions,
  convertTransitionWithCondition: (transition: Transition, context: PathContext) => TTrigger,
  triggerToEdge: (graph: QueryGraph, vertex: Vertex, t: TTrigger) => Edge | null | undefined
): IndirectPaths<TTrigger, V, TNullEdge, TDeadEnds>  {
  const isTopLevelPath = path.isOnTopLevelQueryRoot();
  const typeName = isFederatedGraphRootType(path.tail.type) ? undefined : path.tail.type.name;
  const originalSource = path.tail.source;
  // For each source, we store the best path we find for that source with the score, or `null` if we can
  // decide that we should try going to that source (typically because we can prove that this create an
  // inefficient detour for which a more direct path exists and will be found).
  const bestPathBySource = new Map<string, [GraphPath<TTrigger, V, TNullEdge>, number] | null>();
  const deadEnds: Unadvanceable[] = [];
  const toTry: GraphPath<TTrigger, V, TNullEdge>[] = [ path ];
  while (toTry.length > 0) {
    // Note that through `excluded` we avoid taking the same edge from multiple options. But that means it's important we try
    // the smallest paths first. That is, if we could in theory have path A -> B and A -> C -> B, and we can do B -> D,
    // then we want to keep A -> B -> D, not A -> C -> B -> D.
    const toAdvance = popMin(toTry);
    const nextEdges =  toAdvance.nextEdges().filter(e => !e.transition.collectOperationElements);
    if (nextEdges.length === 0) {
      debug.log(() => `Nothing to try for ${toAdvance}: it has no non-collecting outbound edges`);
      continue;
    }
    debug.group(() => `From ${toAdvance}:`);
    for (const edge of nextEdges) {
      debug.group(() => `Testing edge ${edge}`);
      if (isEdgeExcluded(edge, excludedEdges)) {
        debug.groupEnd(`Ignored: edge is excluded`);
        continue;
      }

      // If the edge takes us back to the subgraph in which we started, we're not really interested
      // (we've already checked for direct transition from that original subgraph). On exception though
      // is if we're just after a @defer, in which case re-entering the current subgraph is actually
      // a thing.
      const target = edge.tail;
      if (target.source === originalSource && !toAdvance.deferOnTail) {
        debug.groupEnd('Ignored: edge get us back to our original source');
        continue;
      }
      // We can only take a non-collecting transition that preserves the current type (typically,
      // jumping subgraphs through a key), with the exception of the federated graph roots, where
      // the type is fake and jumping to any given subgraph is ok and desirable.
      if (typeName && typeName != target.type.name) {
        debug.groupEnd('Ignored: edge does not get to our target type');
        continue;
      }

      // We have edges between Query objects so that if a field returns a query object, we can jump to any subgraph
      // at that point. However, there is no point of using those edges at the beginning of a path, except for when
      // we have a @defer, in which case we want to allow re-jumping to the same subgraph.
      if (isTopLevelPath && edge.transition.kind === 'RootTypeResolution' && !(toAdvance.deferOnTail && edge.isKeyOrRootTypeEdgeToSelf())) {
        debug.groupEnd(`Ignored: edge is a top-level "RootTypeResolution"`);
        continue;
      }

      const prevForSource = bestPathBySource.get(target.source);
      if (prevForSource === null) {
        debug.groupEnd(() => `Ignored: we've shown before than going to ${target.source} is not productive`);
        continue;
      }

      if (prevForSource
        && (prevForSource[0].size < toAdvance.size + 1
          || (prevForSource[0].size == toAdvance.size + 1 && prevForSource[1] <= 1)
        )
      ) {
        // We've already found another path that gets us to the same subgraph than the edge we're
        // about to check. If that previous path is strictly shorter than the path we'd obtain
        // with the new edge, then we don't consider this edge (it's a longer way to get to the same place).
        // And if the previous path is the same size (as the one obtained with that edge), but
        // that the previous path cost for getting the condition was 0 or 1, then the new edge cannot
        // really improve on this and we don't bother with it. Note that a cost of 0 can only happen
        // during composition validation where all costs are 0 to mean "we don't care about costs".
        // Meaning effectively that for validation, as soon as we have a path to a subgraph, we ignore
        // other options even if they may be "faster".
        debug.groupEnd(() => `Ignored: a better (shorter) path to the same subgraph already added`);
        continue;
      }

      if (isConditionExcluded(edge.conditions, excludedConditions)) {
        debug.groupEnd(`Ignored: edge condition is excluded`);
        continue;
      }

      debug.group(() => `Validating conditions ${edge.conditions}`);
      const conditionResolution = canSatisfyConditions(
        toAdvance,
        edge,
        conditionResolver,
        context,
        addEdgeExclusion(excludedEdges, edge),
        excludedConditions,
      );
      if (conditionResolution.satisfied) {
        debug.groupEnd('Condition satisfied');
        // We _can_ get to `target.source` with that edge. But if we had already found another path to
        // the same subgraph, we want to replace it by this one only if either 1) it is shorter or 2) if
        // it's of equal size, only if the condition cost are lower than the previous one.
        if (prevForSource && prevForSource[0].size === toAdvance.size + 1 && prevForSource[1] <= conditionResolution.cost) {
          debug.groupEnd('Ignored: a better (less costly) path to the same subgraph already added');
          continue;
        }

        // It's important we minimize the number of options this method returns, because during query planning
        // with many fields, options here translate to state explosion. This is why we eliminated above
        // edges that provably have better options.
        // But we can do a slightly more involved check. Suppose we have a few subgraph A, B and C,
        // and suppose that we're considering an edge from B to C. We can then look at which subgraph we
        // were into before reaching B (which can be "none" if the query starts at B), and let say that
        // it is A. In other words, if we use the edge we're considering, we'll be looking at a path doing:
        //   ... -> A -> B -> <some fields in B> -> C
        // and `toAdvance` is currently just before that last step.
        // Now, we can fairly easily check if the fields we collected in B (the `<some fields in B>`) can
        // be also collected *directly* (without keys, nor requires) from A and if after that we could take
        // an edge to C. If we can do all that, then we know that the path we're considering is strictly
        // less efficient than doing:
        //   .. -> A -> <same fields but in A> -> C
        // and we've just validated that path exists and so will be found by another branch of the algorithm.
        // In that case, we can ignore the edge, knowing a better path exists.
        // Doing this drastically reduce state explosion in a number of cases.
        const subgraphEnteringEdge = toAdvance.subgraphEnteringEdge;
        // Note that we ignore the case where the "entering edge" is the "current" type as we might end up in an infinite
        // loop when calling `hasValidDirectKeyEdge` in that case without additional care and it's not useful because this
        // very method already ensure we don't create unnecessary chains of keys for the "current type"
        if (subgraphEnteringEdge && edge.transition.kind === 'KeyResolution' && subgraphEnteringEdge.tail.type.name !== typeName) {
          const prevSubgraphVertex = toAdvance.checkDirectPathFomPreviousSubgraphTo(edge.tail.type.name, triggerToEdge);
          const backToPreviousSubgraph = subgraphEnteringEdge.head.source === edge.tail.source;
          const maxCost = toAdvance.subgraphEnteringEdgeCost + (backToPreviousSubgraph ? 0 : conditionResolution.cost);
          if (prevSubgraphVertex
            && (
              backToPreviousSubgraph
              || hasValidDirectKeyEdge(toAdvance.graph, prevSubgraphVertex, edge.tail.source, conditionResolver, maxCost) != undefined
            )
          ) {
            debug.groupEnd(
              () => `Ignored: edge correspond to a detour by subgraph ${edge.head.source} from subgraph ${subgraphEnteringEdge.head.source}: `
              + `we have a direct path from ${subgraphEnteringEdge.head.type} to ${edge.tail.type} in ${subgraphEnteringEdge.head.source}`
              + (backToPreviousSubgraph ? '.' : ` and can move to ${edge.tail.source} from there`)
            );
            // Note that we just found that going to the previous subgraph is useless because there is a more direct path.
            // But we record that this previous subgraph should be avoid altogether because other some longer path
            // could try to get back to that same source but defeat this specific check due to having taken another
            // edge first (and thus the entering edge is different).
            // What we mean here is that if the path is A -> B -> <some fields> and we just found that we don't want to keep
            // A -> B -> <some fields> -> A because we know A -> <some fields> is possible directly, then we don't want this
            // method to later add A -> B -> <some fields> -> C -> A, as that is equally not useful.
            bestPathBySource.set(edge.tail.source, null);
            // We also record a dead-end because this optimization might make us return no path at all, and having
            // recorded no-dead ends would break an assertion in `advancePathWithTransition` that assumes that if
            // we have recorded no-dead end, that's because we have no key edges. But note that this 'dead end'
            // message shouldn't really ever reach users.
            deadEnds.push({
              sourceSubgraph: toAdvance.tail.source,
              destSubgraph: edge.tail.source,
              reason: UnadvanceableReason.IGNORED_INDIRECT_PATH,
              details: `ignoring moving to subgraph "${edge.tail.source}" using @key(fields: "${edge.conditions?.toString(true, false)}") of "${edge.head.type}" because there is a more direct path in ${edge.tail.source} that avoids ${toAdvance.tail.source} altogether."`
            });
            continue;
          }
        }

        const updatedPath = toAdvance.add(convertTransitionWithCondition(edge.transition, context), edge, conditionResolution);
        debug.log(() => `Using edge, advance path: ${updatedPath}`);
        bestPathBySource.set(target.source, [updatedPath, conditionResolution.cost]);
        // It can be necessary to "chain" keys, because different subgraphs may have different keys exposed, and so we when we took
        // a key, we want to check if there is new key we can now take that take us to other subgraphs. For other 'non-collecting'
        // edges ('QueryResolution' and 'SubgraphEnteringTransition') however, chaining never give us additional value.
        // Note: one exception is the case of self-edges (which stay on the same vertex/subgraph): those will only be
        // looked at just after a @defer to handle potentially re-entering the same subgraph. When we take this, no point in
        // looking for chaining since we'll independentely check the other edges already.
        if (edge.transition.kind === 'KeyResolution' && edge.head.source !== edge.tail.source) {
          toTry.push(updatedPath);
        }
      } else {
        debug.groupEnd('Condition unsatisfiable');
        const source = toAdvance.tail.source;
        const dest = edge.tail.source;
        const hasOverriddenField = conditionHasOverriddenFieldsInSource(path.graph.sources.get(toAdvance.tail.source)!, edge.conditions!);
        const extraMsg = hasOverriddenField
          ? ` (note that some of those key fields are overridden in "${source}")`
          : "";
        deadEnds.push({
          sourceSubgraph: source,
          destSubgraph: dest,
          reason: UnadvanceableReason.UNSATISFIABLE_KEY_CONDITION,
          details: `cannot move to subgraph "${dest}" using @key(fields: "${edge.conditions?.toString(true, false)}") of "${edge.head.type}", the key field(s) cannot be resolved from subgraph "${source}"${extraMsg}`
        });
      }
      debug.groupEnd(); // End of edge
    }
    debug.groupEnd();
  }
  return {
    paths: mapValues(bestPathBySource).filter(p => p !== null).map(b => b![0]),
    deadEnds: new Unadvanceables(deadEnds) as TDeadEnds
  }
}

function conditionHasOverriddenFieldsInSource(schema: Schema, condition: SelectionSet): boolean {
  const externalDirective = federationMetadata(schema)!.externalDirective();
  return allFieldDefinitionsInSelectionSet(condition).some((field) => {
    // The subtlety here is that the definition of the fields in the condition are not the one of the subgraph we care
    // about here in general, because the conditions on key edge are those of the destination of the edge, and here
    // we want to check if the field is overridden in the source of the edge. Hence us getting the matching
    // definition in the input schema.
    const typeInSource = schema.type(field.parent.name)
    const fieldInSource = typeInSource && isObjectType(typeInSource) && typeInSource.field(field.name);
    return fieldInSource && fieldInSource.appliedDirectivesOf(externalDirective)?.pop()?.arguments().reason === '[overridden]';
  });
}

function hasValidDirectKeyEdge(
  graph: QueryGraph,
  from: Vertex,
  to: string,
  conditionResolver: ConditionResolver,
  maxCost: number
): boolean {
  for (const edge of graph.outEdges(from)) {
    if (edge.transition.kind !== 'KeyResolution' || edge.tail.source !== to) {
      continue;
    }
    const resolution = conditionResolver(edge, emptyContext, [], []);
    if (!resolution.satisfied) {
      continue;
    }
    // During composition validation, we consider all conditions to have cost 1.
    if (resolution.cost <= maxCost) {
      return true;
    }
  }
  return false;
}

function advancePathWithDirectTransition<V extends Vertex>(
  path: GraphPath<Transition, V>,
  transition: Transition,
  conditionResolver: ConditionResolver
) : GraphPath<Transition, V>[] | Unadvanceables {
  assert(transition.collectOperationElements, "Supergraphs shouldn't have transitions that don't collect elements");

  const options: GraphPath<Transition, V>[] = [];
  const deadEnds: Unadvanceable[] = [];

  for (const edge of path.nextEdges()) {
    // The edge must match the transition. If it doesn't, we cannot use it.
    if (!edge.matchesSupergraphTransition(transition)) {
      continue;
    }

    // Additionally, we can only take an edge if we can satisfy its conditions.
    const conditionResolution = canSatisfyConditions(path, edge, conditionResolver, emptyContext, [], []);
    if (conditionResolution.satisfied) {
      options.push(path.add(transition, edge, conditionResolution));
    } else {
      // The only direct transitions are fields and typeCast, and the later cannot have conditions (the former can, and it
      // is a @require).
      assert(transition.kind === 'FieldCollection', () => `Shouldn't have conditions on direct transition ${transition}`);
      const field = transition.definition;
      const parentTypeInSubgraph = path.graph.sources.get(edge.head.source)!.type(field.parent.name)! as CompositeType;
      const details = conditionResolution.unsatisfiedConditionReason === UnsatisfiedConditionReason.NO_POST_REQUIRE_KEY
        ? `@require condition on field "${field.coordinate}" can be satisfied but missing usable key on "${parentTypeInSubgraph}" in subgraph "${edge.head.source}" to resume query`
        : `cannot satisfy @require conditions on field "${field.coordinate}"${warnOnKeyFieldsMarkedExternal(parentTypeInSubgraph)}`;
      deadEnds.push({
        sourceSubgraph: edge.head.source,
        destSubgraph: edge.head.source,
        reason: UnadvanceableReason.UNSATISFIABLE_REQUIRES_CONDITION,
        details
      });
    }
  }
  if (options.length > 0) {
    return options;
  } else if (deadEnds.length > 0) {
    return new Unadvanceables(deadEnds);
  } else {
    let details: string;
    const subgraph = path.tail.source;
    if (transition.kind === 'FieldCollection') {
      const schema = path.graph.sources.get(subgraph)!;
      const typeInSubgraph = schema.type(path.tail.type.name);
      const fieldInSubgraph = typeInSubgraph && isCompositeType(typeInSubgraph)
        ? typeInSubgraph.field(transition.definition.name)
        : undefined;

      if (fieldInSubgraph) {
        // the subgraph has the field but no corresponding edge. This should only happen if the field is external.
        const externalDirective = fieldInSubgraph.appliedDirectivesOf(federationMetadata(fieldInSubgraph.schema())!.externalDirective()).pop();
        assert(
          externalDirective,
          () => `${fieldInSubgraph.coordinate} in ${subgraph} is not external but there is no corresponding edge (edges from ${path} = [${path.nextEdges().join(', ')}])`
        );
        // but the field is external in the "subgraph-extracted-from-the-supergraph", but it might have been forced to an external
        // due to being a used-overriden field, in which case we want to amend the message to avoid confusing the user.
        // Note that the subgraph extraction marks such "forced external due to being overriden" by setting the "reason" to "[overridden]".
        const overriddingSources = externalDirective.arguments().reason === '[overridden]'
          ? findOverriddingSourcesIfOverridden(fieldInSubgraph, subgraph, path.graph.sources)
          : [];
        if (overriddingSources.length > 0) {
          details = `field "${transition.definition.coordinate}" is not resolvable because it is overridden by ${printSubgraphNames(overriddingSources)}`;
        } else {
          details = `field "${transition.definition.coordinate}" is not resolvable because marked @external`;
        }
      } else {
        details = `cannot find field "${transition.definition.coordinate}"`;
      }
    } else {
      assert(transition.kind === 'DownCast', () => `Unhandled direct transition ${transition} of kind ${transition.kind}`);
      details = `cannot find type "${transition.castedType}"`;
    }
    return new Unadvanceables([{
      sourceSubgraph: subgraph,
      destSubgraph: subgraph,
      reason: UnadvanceableReason.NO_MATCHING_TRANSITION,
      details
    }]);
  }
}

function findOverriddingSourcesIfOverridden(
  field: FieldDefinition<CompositeType>,
  fieldSource: string,
  sources: ReadonlyMap<string, Schema>,
): string[] {
  return [...sources.entries()]
    .map(([name, schema]) => {
      if (name === FEDERATED_GRAPH_ROOT_SOURCE || name === fieldSource) {
        return undefined;
      }
      const sourceMetadata = federationMetadata(schema)!;
      const typeInSource = schema.type(field.parent.name);
      if (!typeInSource || !isObjectType(typeInSource)) {
        return undefined;
      }
      const fieldInSource = typeInSource.field(field.name);
      const isOverriddingSource = fieldInSource?.appliedDirectivesOf(sourceMetadata.overrideDirective())?.pop()?.arguments()?.from === fieldSource;
      return isOverriddingSource ? name : undefined;
    })
    .filter((name) => !!name) as string[];
}

function warnOnKeyFieldsMarkedExternal(type: CompositeType): string {
  // Because fed 1 used to (somewhat wrongly) require @external on key fields of type extension and because fed 2 allows you
  // to avoid type extensions, users upgrading might try to remove `extend` from their schema, but forgot to remove the @external
  // on their key field. The problem is that doing that make the key field truly external, and that could easily make @require
  // condition no satisfiable (because the key you'd need to get the require is now external). To help user locate that mistake
  // we add a specific pointer to this potential problem is the type is indeed an entity.
  const metadata = federationMetadata(type.schema());
  assert(metadata, "Type should originate from a federation subgraph schema");
  const keyDirective = metadata.keyDirective();
  const keys = type.appliedDirectivesOf(keyDirective);
  if (keys.length === 0) {
    return "";
  }
  const keyFieldMarkedExternal: string[] = [];
  for (const key of keys) {
    const fieldSet = parseFieldSetArgument({ parentType: type, directive: key });
    for (const selection of fieldSet.selections()) {
      if (selection.kind === 'FieldSelection' && selection.field.definition.hasAppliedDirective(metadata.externalDirective())) {
        const fieldName = selection.field.name;
        if (!keyFieldMarkedExternal.includes(fieldName)) {
          keyFieldMarkedExternal.push(fieldName);
        }
      }
    }
  }
  if (keyFieldMarkedExternal.length === 0) {
    return "";
  }
  const printedFields = keyFieldMarkedExternal.map(f => `"${f}"`).join(', ');
  const fieldWithPlural = keyFieldMarkedExternal.length === 1 ? 'field' : 'fields';
  return ` (please ensure that this is not due to key ${fieldWithPlural} ${printedFields} being accidentally marked @external)`;
}

export function getLocallySatisfiableKey(graph: QueryGraph, typeVertex: Vertex): SelectionSet | undefined  {
  const type = typeVertex.type as CompositeType;
  const schema = graph.sources.get(typeVertex.source);
  const metadata = schema ? federationMetadata(schema) : undefined;
  assert(metadata, () => `Could not find federation metadata for source ${typeVertex.source}`);
  const keyDirective = metadata.keyDirective();
  for (const key of type.appliedDirectivesOf(keyDirective)) {
    const selection = parseFieldSetArgument({ parentType: type, directive: key });
    if (!metadata.selectionSelectsAnyExternalField(selection)) {
      return selection;
    }
  }
  return undefined;
}

function canSatisfyConditions<TTrigger, V extends Vertex, TNullEdge extends null | never = never>(
  path: GraphPath<TTrigger, V, TNullEdge>,
  edge: Edge,
  conditionResolver: ConditionResolver,
  context: PathContext,
  excludedEdges: ExcludedEdges,
  excludedConditions: ExcludedConditions
): ConditionResolution {
  const conditions = edge.conditions;
  if (!conditions) {
    return noConditionsResolution;
  }
  debug.group(() => `Checking conditions ${conditions} on edge ${edge}`);
  const resolution = conditionResolver(edge, context, excludedEdges, excludedConditions);
  if (!resolution.satisfied) {
    debug.groupEnd('Conditions are not satisfied');
    return unsatisfiedConditionsResolution;
  }
  const pathTree = resolution.pathTree;
  const lastEdge = path.lastEdge();
  if (edge.transition.kind === 'FieldCollection'
    && lastEdge !== null
    && lastEdge?.transition.kind !== 'KeyResolution'
    && (!pathTree || pathTree.isAllInSameSubgraph())) {

    debug.log('@requires conditions are satisfied, but validating post-require key.');
    const postRequireKeyCondition = getLocallySatisfiableKey(path.graph, edge.head);
    if (!postRequireKeyCondition) {
      debug.groupEnd('Post-require conditions cannot be satisfied');
      return { ...unsatisfiedConditionsResolution, unsatisfiedConditionReason: UnsatisfiedConditionReason.NO_POST_REQUIRE_KEY };
    }

    // We're in a case where we have a `@require` (we have a condition but we're a 'FieldCollection') and we
    // have to jump to other subgraph to satisfy the require, which means we need to use a key on "the current
    // subgraph" to resume collecting the field with the require. `getLocallySatisfiableKey` essentially tells
    // us that we have such key, and that's good enough here. Not that the way the code is organised, we don't
    // use an actual edge of the query graph, so we cannot use `conditionResolver` and so it's not easy to
    // get a proper cost or tree. That's ok in the sense that the cost of the key is negligible because we
    // know it's a "local" one (there is no subgraph jump) and the code to build plan will deal with adding
    // that key anyway (so not having the tree is ok).
    // TODO(Sylvain): the whole hanlding of @require is a bit too complex and hopefully we might be able to
    // clean that up, but it's unclear to me how at the moment and it may not be a small change so this will
    // have to do for now.
  }
  debug.groupEnd('Conditions satisfied');
  return resolution;
}

function isTerminalOperation(operation: OperationElement): boolean {
  return operation.kind === 'Field' && isLeafType(baseType(operation.definition.type!));
}

export type SimultaneousPaths<V extends Vertex = Vertex> = OpGraphPath<V>[];

type OpIndirectPaths<V extends Vertex> = IndirectPaths<OpTrigger, V, null, never>;

/**
 * Memoize the computation of indirect paths, like `TransitionPathWithLazyIndirectPaths` does, but for query planning.
 *
 * Here again, this is an optimization that avoids computing indirect paths eagerly (since we may not need them) but
  * ensures we don't re-do their computation multiple times when we do need them multiple times.
 */
export class SimultaneousPathsWithLazyIndirectPaths<V extends Vertex = Vertex> {
  private lazilyComputedIndirectPaths: OpIndirectPaths<V>[];

  constructor(
    readonly paths: SimultaneousPaths<V>,
    readonly context: PathContext,
    readonly conditionResolver: ConditionResolver,
    readonly excludedNonCollectingEdges: ExcludedEdges = [],
    readonly excludedConditionsOnNonCollectingEdges: ExcludedConditions = [],
  ) {
    this.lazilyComputedIndirectPaths = new Array(paths.length);
  }

  // For a given "input" path (identified by an idx in `paths`), each of its indirect options.
  indirectOptions(updatedContext: PathContext, pathIdx: number): OpIndirectPaths<V> {
    // Note that the provided context will usually be one we had during construction (the `updatedContext` will be `this.context` updated
    // by whichever operation we're looking at, but only operation with a @skip/@include will change the context so it's pretty rare),
    // which is why we save recomputation by caching the computed value in that case, but in case it's different, we compute without caching.
    if (updatedContext !== this.context) {
      return this.computeIndirectPaths(pathIdx);
    }
    if (!this.lazilyComputedIndirectPaths[pathIdx]) {
      this.lazilyComputedIndirectPaths[pathIdx] = this.computeIndirectPaths(pathIdx);
    }
    return this.lazilyComputedIndirectPaths[pathIdx];
  }

  private computeIndirectPaths(idx: number): OpIndirectPaths<V>  {
    return advancePathWithNonCollectingAndTypePreservingTransitions(
      this.paths[idx],
      this.context,
      this.conditionResolver,
      this.excludedNonCollectingEdges,
      this.excludedConditionsOnNonCollectingEdges,
      // the transitions taken by this function are non collecting transitions, and we ship the context as trigger (a slight hack admittedly,
      // but as we'll need the context handy for keys ...).
      (_t, context) => context,
      opPathTriggerToEdge
    );
  }

  toString(): string {
    return simultaneousPathsToString(this.paths);
  }
}

export function simultaneousPathsToString(simultaneousPaths: SimultaneousPaths<any> | SimultaneousPathsWithLazyIndirectPaths<any>, indentOnNewLine: string=""): string {
  const paths = Array.isArray(simultaneousPaths) ? simultaneousPaths : simultaneousPaths.paths;
  if (paths.length === 0) {
    return '<no path>';
  }
  if (paths.length === 1) {
    return paths[0].toString();
  }
  return `{\n${indentOnNewLine}  ` + paths.join(`\n${indentOnNewLine}  `) + `\n${indentOnNewLine}}`;
}

export function advanceOptionsToString(options: (SimultaneousPaths<any> | SimultaneousPathsWithLazyIndirectPaths<any> | GraphPath<any>)[] | undefined): string {
  if (!options) {
    return '<no options>';
  }
  if (options.length === 0) {
    return '<unsatisfiable branch>';
  }
  if (options.length === 1) {
    return '[' + options[0] + ']';
  }
  return '[\n  ' + options.map(opt => Array.isArray(opt) ? simultaneousPathsToString(opt, "  ") : opt.toString()).join('\n  ') + '\n]';
}

// Returns undefined if the operation cannot be dealt with/advanced. Otherwise, it returns a list of options we can be in after advancing the operation, each option
// being a set of simultaneous paths in the subgraphs (a single path in the simple case, but type exploding may make us explore multiple paths simultaneously).
// The lists of options can be empty, which has the special meaning that the operation is guaranteed to have no results (it corresponds to unsatisfiable conditions),
// meaning that as far as query planning goes, we can just ignore the operation but otherwise continue.
export function advanceSimultaneousPathsWithOperation<V extends Vertex>(
  supergraphSchema: Schema,
  subgraphSimultaneousPaths: SimultaneousPathsWithLazyIndirectPaths<V>,
  operation: OperationElement,
) : SimultaneousPathsWithLazyIndirectPaths<V>[] | undefined {
  debug.group(() => `Trying to advance ${simultaneousPathsToString(subgraphSimultaneousPaths)} for ${operation}`);
  const updatedContext = subgraphSimultaneousPaths.context.withContextOf(operation);
  const optionsForEachPath: SimultaneousPaths<V>[][] = [];
  for (const [i, path] of subgraphSimultaneousPaths.paths.entries()) {
    let options: SimultaneousPaths<V>[] | undefined = undefined;

    debug.group(() => `Computing options for ${path}`);
    // If we're just entering a deferred section, then we will need to re-enter subgraphs, so we should not consider
    // direct options and instead force and indirect path.
    if (!path.deferOnTail) {
      debug.group(() => `Direct options`);
      options = advanceWithOperation(
        supergraphSchema,
        path,
        operation,
        updatedContext,
        subgraphSimultaneousPaths.conditionResolver
      );
      debug.groupEnd(() => advanceOptionsToString(options));
      // If we got some options, there is number of cases where there is no point looking for indirect paths:
      // - if the operation is terminal: this mean we just found a direct edge that is terminal, so no
      //   indirect options could be better (this is no true for non-terminal where the direct route may
      //   end up being a dead end later).
      // - if we get options, but an empty set of them, which signifies the operation correspond to unsatisfiable
      //   conditions and we can essentially ignore it.
      // - if the operation is a fragment in general: if we were able to find a direct option, that means the type
      //   is known in the "current" subgraph, and so we'll still be able to take any indirect edges that we could
      //   take now later, for the follow-up operation. And pushing the decision will give us more context and may
      //   avoid a bunch of state explosion in practice.
      if (options && (options.length === 0 || isTerminalOperation(operation) || operation.kind === 'FragmentElement')) {
        debug.groupEnd(() => `Final options for ${path}: ${advanceOptionsToString(options)}`);
        // Note that options is empty, that means this particular "branch" is unsatisfiable, so we should just ignore it.
        if (options.length > 0) {
          optionsForEachPath.push(options);
        }
        continue;
      }
    }

    // If there was not valid direct path (or we didn't check those because we enter a defer), that's ok, we'll just try with non-collecting edges.
    options = options ?? [];
    debug.group(`Computing indirect paths:`);
    // Then adds whatever options can be obtained by taking some non-collecting edges first.
    const pathsWithNonCollecting = subgraphSimultaneousPaths.indirectOptions(updatedContext, i);
    debug.groupEnd(() => pathsWithNonCollecting.paths.length == 0 ? `no indirect paths` : `${pathsWithNonCollecting.paths.length} indirect paths`);
    if (pathsWithNonCollecting.paths.length > 0) {
      debug.group('Validating indirect options:');
      for (const pathWithNonCollecting of pathsWithNonCollecting.paths) {
        debug.group(() => `For indirect path ${pathWithNonCollecting}:`);
        const pathWithOperation = advanceWithOperation(
          supergraphSchema,
          pathWithNonCollecting,
          operation,
          updatedContext,
          subgraphSimultaneousPaths.conditionResolver
        );
        // If we can't advance the operation after that path, ignore it, it's just not an option.
        if (!pathWithOperation) {
          debug.groupEnd(() => `Ignoring: cannot be advanced with ${operation}`);
          continue;
        }
        debug.groupEnd(() => `Adding valid option: ${pathWithOperation}`);
        // advancedWithOperation can return an empty list only if the operation if a fragment with a condition that, on top of the "current" type
        // is unsatisfiable. But as we've only taken type preserving transitions, we cannot get an empty results at this point if we haven't
        // had one when testing direct transitions above (in which case we have exited the method early).
        assert(pathWithOperation.length > 0, () => `Unexpected empty options after non-collecting path ${pathWithNonCollecting} for ${operation}`);
        options = options.concat(pathWithOperation);
      }
      debug.groupEnd();
    }

    // If we were entering a @defer, we've skipped the potential "direct" options because we need an "indirect" one (a key/root query)
    // to be able to actualy defer. But in rare cases, it's possible we actually couldn't resolve the key fields needed to take a key
    // but could still find a direct path. If so, it means it's a corner case where we cannot do query-planner-based-@defer and have
    // to fall back on not deferring.
    if (options.length === 0 && path.deferOnTail) {
      debug.group(() => `Cannot defer (no indirect options); falling back to direct options`);
      options = advanceWithOperation(
        supergraphSchema,
        path,
        operation,
        updatedContext,
        subgraphSimultaneousPaths.conditionResolver
      ) ?? [];
      debug.groupEnd(() => advanceOptionsToString(options));
    }

    // At this point, if options is empty, it means we found no ways to advance the operation for this path, so we should return undefined.
    if (options.length === 0) {
      debug.groupEnd(); // end of this input path
      debug.groupEnd(() => `No valid options for ${operation}, aborting operation ${operation}`);
      return undefined;
    } else {
      debug.groupEnd(() => advanceOptionsToString(options));
      optionsForEachPath.push(options);
    }
  }

  const allOptions: SimultaneousPaths<V>[] = flatCartesianProduct(optionsForEachPath);
  debug.groupEnd(() => advanceOptionsToString(allOptions));
  return createLazyOptions(allOptions, subgraphSimultaneousPaths, updatedContext);
}

export function createInitialOptions<V extends Vertex>(
  initialPath: OpGraphPath<V>,
  initialContext: PathContext,
  conditionResolver: ConditionResolver,
  excludedEdges: ExcludedEdges,
  excludedConditions: ExcludedConditions,
): SimultaneousPathsWithLazyIndirectPaths<V>[] {
  const lazyInitialPath = new SimultaneousPathsWithLazyIndirectPaths(
    [initialPath],
    initialContext,
    conditionResolver,
    excludedEdges,
    excludedConditions
  );
  if (isFederatedGraphRootType(initialPath.tail.type)) {
    const initialOptions = lazyInitialPath.indirectOptions(initialContext, 0);
    return createLazyOptions(initialOptions.paths.map(p => [p]), lazyInitialPath, initialContext);
  } else {
    return [lazyInitialPath];
  }
}

function createLazyOptions<V extends Vertex>(
  options: SimultaneousPaths<V>[],
  origin: SimultaneousPathsWithLazyIndirectPaths<V>,
  context: PathContext
) : SimultaneousPathsWithLazyIndirectPaths<V>[] {
  return options.map(option => new SimultaneousPathsWithLazyIndirectPaths(
    option,
    context,
    origin.conditionResolver,
    origin.excludedNonCollectingEdges,
    origin.excludedConditionsOnNonCollectingEdges
  ));
}

function opPathTriggerToEdge(graph: QueryGraph, vertex: Vertex, trigger: OpTrigger): Edge | null | undefined {
  if (trigger instanceof PathContext) {
    return undefined;
  }
  if (trigger.kind === 'Field') {
    return edgeForField(graph, vertex, trigger);
  } else {
    return trigger.typeCondition ? edgeForTypeCast(graph, vertex, trigger.typeCondition.name) : null;
  }
}

// This can be written more tersely with a bunch of reduce/flatMap and friends, but when interfaces type-explode into many
// implementations, this can end up with fairly large arrays and be a bottleneck, and a more iterative version that pre-allocate
// arrays is quite a bit faster.
function flatCartesianProduct<V>(arr:V[][][]): V[][] {
  const size = arr.length;
  if (size === 0) {
    return [];
  }

  // Track, for each element, at which index we are
  const eltIndexes = new Array<number>(size);
  let totalCombinations = 1;
  for (let i = 0; i < size; ++i){
    const eltSize = arr[i].length;
    if(!eltSize) {
      totalCombinations = 0;
      break;
    }
    eltIndexes[i] = 0;
    totalCombinations *= eltSize;
  }

  const product = new Array<V[]>(totalCombinations);
  for (let i = 0; i < totalCombinations; ++i){
    let itemSize = 0;
    for (let j = 0; j < size; ++j) {
      itemSize += arr[j][eltIndexes[j]].length;
    }
    const item = new Array<V>(itemSize);
    let k = 0;
    for (let j = 0; j < size; ++j) {
      for (const v of arr[j][eltIndexes[j]]) {
        item[k++] = v;
      }
    }
    product[i] = item;

    for (let idx = 0; idx < size; ++idx) {
      if (eltIndexes[idx] == arr[idx].length - 1) {
        eltIndexes[idx] = 0;
      } else {
        eltIndexes[idx] += 1;
        break;
      }
    }
  }
  return product;
}

function anImplementationHasAProvides(fieldName: string, itf: InterfaceType): boolean {
  const metadata = federationMetadata(itf.schema());
  assert(metadata, "Interface should have come from a federation subgraph");
  for (const implem of itf.possibleRuntimeTypes()) {
    const field = implem.field(fieldName);
    // Note that this should only be called if field exists, but no reason to fail otherwise.
    if (field && field.hasAppliedDirective(metadata.providesDirective())) {
      return true;
    }
  }
  return false;
}

function isProvidedEdge(edge: Edge): boolean {
  return edge.transition.kind === 'FieldCollection' && edge.transition.isPartOfProvide;
}

// The result has the same meaning than in advanceSimultaneousPathsWithOperation.
// We also actually need to return a set of options of simultaneous paths. Cause when we type explode, we create simultaneous paths, but
// as a field might be resolve by multiple subgraphs, we may have options created.
function advanceWithOperation<V extends Vertex>(
  supergraphSchema: Schema,
  path: OpGraphPath<V>,
  operation: OperationElement,
  context: PathContext,
  conditionResolver: ConditionResolver,
) : SimultaneousPaths<V>[] | undefined {
  debug.group(() => `Trying to advance ${path} directly with ${operation}`);

  const currentType = path.tail.type;
  if (isFederatedGraphRootType(currentType)) {
    // We cannot advance any operation from there: we need to take the initial non-collecting edges first.
    debug.groupEnd('Cannot advance federated graph root with direct operations');
    return undefined;
  }

  if (operation.kind === 'Field') {
    const field = operation.definition;
    switch (currentType.kind) {
      case 'ObjectType':
        // Just take the edge corresponding to the field, if it exists and can be used.
        const edge = nextEdgeForField(path, operation);
        if (!edge) {
          debug.groupEnd(() => `No edge for field ${field} on object type ${currentType}`);
          return undefined;
        }
        const fieldOptions = addFieldEdge(path, operation, edge, conditionResolver, context);
        debug.groupEnd(() => fieldOptions
          ? `Collected field ${field} on object type ${currentType}`
          : `Cannot satisfy @requires on field ${field} for object type ${currentType}`
        );
        return fieldOptions;
      case 'InterfaceType':
        // First, we check if there is a direct edge from the interface (which only happens if we're in a subgraph that knows all of the
        // implementations of that interface globally and all of them resolve the field).
        // If there is one, then we have 2 options: either we take that edge, or we type-explode (like when we don't have a direct interface edge).
        // In general, taking the interface edge is better than type explosion. However, there is a special case: if the field has a @provides in
        // at least some of the implementations. In that case, it could be that type-exploding ends up faster because the @provides saves on a fetch
        // we have to do if we take the direct edge. So if any implementation has a @provides, we include both options (direct interface or type explosion
        // and let the later query-plan "cost" evaluation decide what is best).
        const itfEdge = nextEdgeForField(path, operation);
        let itfOptions: SimultaneousPaths<V>[] | undefined = undefined;
        if (itfEdge) {
          itfOptions = addFieldEdge(path, operation, itfEdge, conditionResolver, context);
          // TODO: We should re-assess this when we support @requires on interface fields (typically, should we even try to type-explode
          // if the direct edge cannot be satisfied? Probably depends on the exact semantic of @requires on interface fields).
          assert(itfOptions, () => `Interface edge ${itfEdge} shouldn't have conditions`);
          // Further, if we've getting the __typename, we must _not_ type-explode.
          if (field.name === typenameFieldName || (!isProvidedEdge(itfEdge) && !anImplementationHasAProvides(field.name, currentType))) {
            debug.groupEnd(() => `Collecting field ${field} on interface ${currentType} without type-exploding`);
            return itfOptions;
          } else {
            debug.log(() => `Collecting field ${field} on interface ${currentType} as 1st option`);
          }
        }
        // Otherwise, that means we need to type explode and descend into every possible implementations (implementations "in the current
        // subgraph", since the previous edge to this interface had to come from the current subgraph and can thus only have returned
        // local implementations).
        // TODO: once we add @key on interfaces, this will have to be updated.
        const implementations = path.tailPossibleRuntimeTypes();
        debug.log(() => !itfOptions
          ? `No direct edge: type exploding interface ${currentType} into possible runtime types [${implementations.join(', ')}]`
          : `Type exploding interface ${currentType} into possible runtime types [${implementations.join(', ')}] as 2nd option`
        );
        // For all implementations, We need to call advanceSimultaneousPathsWithOperation on a made-up Fragment. If any
        // gives use empty options, we bail.
        const optionsByImplems: OpGraphPath<V>[][][] = [];
        for (const implemType of implementations) {
          const castOp = new FragmentElement(currentType, implemType.name);
          debug.group(() => `Handling implementation ${implemType}`);
          const implemOptions = advanceSimultaneousPathsWithOperation(
            supergraphSchema,
            new SimultaneousPathsWithLazyIndirectPaths([path], context, conditionResolver),
            castOp
          );
          // If we find no option for that implementation, we bail (as we need to simultaneously advance all implementations).
          if (!implemOptions) {
            debug.groupEnd();
            debug.groupEnd(() => `Cannot collect field ${field} from ${implemType}: stopping with options ${advanceOptionsToString(itfOptions)}`);
            return itfOptions;
          }
          // If the new fragment makes it so that we're on an unsatisfiable branch, we just ignore that implementation.
          if (implemOptions.length === 0) {
            debug.groupEnd(() => `Cannot ever get ${implemType} from this branch, ignoring it`);
            continue;
          }
          // For each option, we call advanceSimultaneousPathsWithOperation again on our own operation (the field),
          // which gives us some options (or not and we bail).
          let withField: SimultaneousPaths<V>[] = [];
          debug.log(() => `Trying to collect ${field} from options ${advanceOptionsToString(implemOptions)}`);
          for (const optPaths of implemOptions) {
            debug.group(() => `For ${simultaneousPathsToString(optPaths)}`);
            const withFieldOptions = advanceSimultaneousPathsWithOperation(
              supergraphSchema,
              optPaths,
              operation
            );
            if (!withFieldOptions) {
              debug.groupEnd(() => `Cannot collect ${field}`);
              continue;
            }
            // Advancing a field should never get us into an unsatisfiable condition. Only fragments can.
            assert(withFieldOptions.length > 0, () => `Unexpected unsatisfiable path after ${optPaths} for ${operation}`);
            debug.groupEnd(() => `Collected field ${field}: adding ${advanceOptionsToString(withFieldOptions)}`);
            withField = withField.concat(withFieldOptions.map(opt => opt.paths));
          }
          // If we find no option to advance that implementation, we bail (as we need to simultaneously advance all implementations).
          if (withField.length === 0) {
            debug.groupEnd(); // implem group
            debug.groupEnd(() => `Cannot collect field ${field} from ${implemType}: stopping with options ${advanceOptionsToString(itfOptions)}`);
            return itfOptions;
          }
          debug.groupEnd(() => `Collected field ${field} from ${implemType}`);
          optionsByImplems.push(withField);
        }
        const implemOptions = flatCartesianProduct(optionsByImplems);
        const allOptions = itfOptions ? itfOptions.concat(implemOptions) : implemOptions;
        debug.groupEnd(() => `With type-exploded options: ${advanceOptionsToString(allOptions)}`);
        return allOptions;
      case 'UnionType':
        assert(field.name === typenameFieldName, () => `Invalid field selection ${operation} for union type ${currentType}`);
        const typenameEdge = nextEdgeForField(path, operation);
        assert(typenameEdge, `Should always have an edge for __typename edge on an union`);
        debug.groupEnd(() => `Trivial collection of __typename for union ${currentType}`);
        return addFieldEdge(path, operation, typenameEdge, conditionResolver, context);
      default:
        // Only object, interfaces and unions (only for __typename) have fields so the query should have been flagged invalid if a field was selected on something else.
        assert(false, `Unexpected ${currentType.kind} type ${currentType} from ${path.tail} given operation ${operation}`);
    }
  } else {
    assert(operation.kind === 'FragmentElement', () => "Unhandled operation kind: " + operation.kind);
    if (!operation.typeCondition || currentType.name === operation.typeCondition.name) {
      // If there is no typename (or the condition is the type we're already one), it means we're essentially
      // just applying some directives (could be a @skip/@include for instance). This doesn't make us take any
      // edge but if operation does have directives, we record it.
      debug.groupEnd(() => `No edge to take for condition ${operation} from current type ${currentType}`);
      const updatedPath = operation.appliedDirectives.length > 0
        ? path.add(operation, null, noConditionsResolution, operation.deferDirectiveArgs())
        : path;
      return [[ updatedPath ]];
    }
    const typeName = operation.typeCondition.name;
    switch (currentType.kind) {
      case 'InterfaceType':
      case 'UnionType':
        // If we have an edge for the type case, take that.
        const edge = nextEdgeForTypeCast(path, typeName);
        if (edge) {
          assert(!edge.conditions, "TypeCast collecting edges shouldn't have conditions");
          debug.groupEnd(() => `Using type-casting edge for ${typeName} from current type ${currentType}`);
          return [[path.add(operation, edge, noConditionsResolution, operation.deferDirectiveArgs())]];
        }
        // Otherwise, checks what is the intersection between the possible runtime types of the current type
        // and the ones of the cast. We need to be able to go into all those types simultaneously.
        const parentTypes = path.tailPossibleRuntimeTypes() ;
        const castedTypes = possibleRuntimeTypes(supergraphSchema.type(typeName) as CompositeType);
        const intersection = parentTypes.filter(t1 => castedTypes.some(t2 => t1.name === t2.name)).map(t => t.name);
        debug.log(() => `Trying to type-explode into intersection between ${currentType} and ${typeName} = [${intersection}]`);
        const optionsByImplems: OpGraphPath<V>[][][] = [];
        for (const tName of intersection) {
          debug.group(() => `Trying ${tName}`);
          const castOp = new FragmentElement(currentType, tName);
          const implemOptions = advanceSimultaneousPathsWithOperation(
            supergraphSchema,
            new SimultaneousPathsWithLazyIndirectPaths([path], context, conditionResolver),
            castOp,
          );
          if (!implemOptions) {
            debug.groupEnd();
            debug.groupEnd(() => `Cannot advance into ${tName} from ${currentType}: no options for ${operation}.`);
            return undefined;
          }
          // If the new fragment makes it so that we're on an unsatisfiable branch, we just ignore that implementation.
          if (implemOptions.length === 0) {
            debug.groupEnd(() => `Cannot ever get ${tName} from this branch, ignoring it`);
            continue;
          }
          debug.groupEnd(() => `Advanced into ${tName} from ${currentType}: ${advanceOptionsToString(implemOptions)}`);
          optionsByImplems.push(implemOptions.map(opt => opt.paths));
        }
        const allCastOptions = flatCartesianProduct(optionsByImplems);
        debug.groupEnd(() => `Type-exploded options: ${advanceOptionsToString(allCastOptions)}`);
        return allCastOptions;
      case 'ObjectType':
        // We've already handled the case of a fragment whose condition is this type. But the fragment might
        // be for either:
        // - a super-type of the current type: in which case, we're pretty much in the same case than if there
        //   were no particular condition.
        // - another, incompatible type. This can happen for a type that intersects a super-type of the
        //   current type (since graphQL allows a fragment as long as there is an intersection). In that
        //   case, the whole operation simply cannot ever return anything.
        const conditionType = supergraphSchema.type(typeName)!;
        if (isAbstractType(conditionType) && possibleRuntimeTypes(conditionType).some(t => t.name == currentType.name)) {
          debug.groupEnd(() => `${typeName} is a super-type of current type ${currentType}: no edge to take`);
          const updatedPath = operation.appliedDirectives.length > 0
            ? path.add(operation, null, noConditionsResolution, operation.deferDirectiveArgs())
            : path;
          return [[ updatedPath ]];
        }
        // The operation we're dealing with can never return results (the type conditions applies have no intersection).
        // This means we _can_ fulfill this operation (by doing nothing and returning an empty result), which we indicate
        // by return an empty list of options.
        debug.groupEnd(() => `Cannot ever get ${typeName} from current type ${currentType}: returning empty branch`);
        return [];
      default:
        // We shouldn't have a fragment on a non-selectable type
        assert(false, `Unexpected ${currentType.kind} type ${currentType} from ${path.tail} given operation ${operation}`);
    }
  }
}

function addFieldEdge<V extends Vertex>(
  path: OpGraphPath<V>,
  fieldOperation: Field<any>,
  edge: Edge,
  conditionResolver: ConditionResolver,
  context: PathContext
): SimultaneousPaths<V>[] | undefined {
  const conditionResolution = canSatisfyConditions(path, edge, conditionResolver, context, [], []);
  return conditionResolution.satisfied ? [[ path.add(fieldOperation, edge, conditionResolution) ]] : undefined;
}

function nextEdgeForField<V extends Vertex>(
  path: OpGraphPath<V>,
  field: Field<any>
): Edge | undefined {
  return edgeForField(path.graph, path.tail, field);
}

function edgeForField(
  graph: QueryGraph,
  vertex: Vertex,
  field: Field<any>
): Edge | undefined {
  const candidates = graph.outEdges(vertex).filter(e => e.transition.kind === 'FieldCollection' && field.selects(e.transition.definition, true));
  assert(candidates.length <= 1, () => `Vertex ${vertex} has multiple edges matching ${field} (${candidates})`);
  return candidates.length === 0 ? undefined : candidates[0];
}

function nextEdgeForTypeCast<V extends Vertex>(
  path: OpGraphPath<V>,
  typeName: string
): Edge | undefined {
  return edgeForTypeCast(path.graph, path.tail, typeName);
}

function edgeForTypeCast(
  graph: QueryGraph,
  vertex: Vertex,
  typeName: string
): Edge | undefined {
  const candidates = graph.outEdges(vertex).filter(e => e.transition.kind === 'DownCast' && typeName === e.transition.castedType.name);
  assert(candidates.length <= 1, () => `Vertex ${vertex} has multiple edges matching ${typeName} (${candidates})`);
  return candidates.length === 0 ? undefined : candidates[0];
}
