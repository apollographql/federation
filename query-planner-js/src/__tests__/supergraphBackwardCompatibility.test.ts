import { composeServices } from '@apollo/composition';
import { asFed2SubgraphDocument, assert, buildSupergraphSchema, isDefined, operationFromDocument, Schema } from '@apollo/federation-internals';
import fs from 'fs';
import gql from 'graphql-tag';
import path from 'path';
import { astSerializer, queryPlanSerializer, QueryPlanner } from '..';

/*
 * The test of this file tries to ensure that the current query planner can correctly read and use older
 * supergraph formats.
 *
 * However, newer versions can read older supergraph versions but cannot write them, so this file uses
 * pre-computed supergraphs generated by older versions of the code. For a given code version, its
 * supergraph can be generated by calling the `generateTestSupergraph` method. This method should ideally
 * be called for every new release and the resulting file committed.
 *
 */


const accounts = {
  name: 'accounts',
  typeDefs: gql`
    type Query {
      userById(id: ID!): User
      me: User! @shareable
    }

    type User @key(fields: "id") {
      id: ID!
      name: String
      email: String
      password: String
      nickname: String @override(from: "reviews")
    }
  `
}

const products = {
  name: 'products',
  typeDefs: gql`
    type Query {
      productById(id: ID!): Product
      search(filter: SearchFilter): [Product]
    }

    input SearchFilter {
      pattern: String!
      vendorName: String
    }

    interface Product {
      id: ID!
      price: Price
      vendor: User
      avg_rating: Int
    }

    type Review {
      rating: Int @external
    }

    type Movie implements Product @key(fields: "id")  {
      id: ID!
      price: Price
      title: String
      vendor: User
      length_minutes: Int
      avg_rating: Int @requires(fields: "reviews { rating }")
      reviews: [Review] @external
    }

    type Book implements Product @key(fields: "id") {
      id: ID!
      price: Price
      title: String
      vendor: User
      pages: Int
      avg_rating: Int @requires(fields: "reviews { rating }")
      reviews: [Review] @external
    }

    type User @key(fields: "id", resolvable: false) {
      id: ID!
    }

    type Price {
      value: Int
      currency: Currency
    }

    enum Currency {
      USD
      EUR
    }
  `
}

const reviews = {
  name: 'reviews',
  typeDefs: gql`
    type Query {
      me: User! @shareable
      bestRatedProducts(limit: Int): [Product]
    }

    type User @key(fields: "id") {
      id: ID!
      nickname: String
      reviews: [Review]
    }

    type Review {
      product: Product
      author: User
      text: String
      rating: Int
    }

    interface Product {
      id: ID!
      reviews: [Review]
    }

    type Movie implements Product @key(fields: "id") {
      id: ID!
      reviews: [Review]
    }

    type Book implements Product @key(fields: "id") {
      id: ID!
      reviews: [Review]
    }
  `
}

const testSupergraphDir = path.join(__dirname, 'testSupergraphs');

function testSupergraphPath(v: string): fs.PathLike {
  return path.join(testSupergraphDir, `testSupergraph_${v}.graphql`);
}

export function generateTestSupergraph(v: string) {
  const services = [ accounts, products, reviews ];
  const res =  composeServices(
    services.map((s) => ({ ...s, typeDefs: asFed2SubgraphDocument(s.typeDefs) }))
  );
  assert(!res.errors, `Expected to compose but got errors:\n${res.errors?.join('\n\n')}`);
  fs.writeFileSync(testSupergraphPath(v), res.supergraphSdl);
}

type TestSupergraph = {
  version: string,
  supergraph: Schema,
  api: Schema,
}

function listTestSupergraphs(): TestSupergraph[] {
  return fs.readdirSync(testSupergraphDir).map((file) => {
    if (!file.startsWith('testSupergraph_')) {
      return undefined;
    }
    const version = file.slice('testSupergraph_'.length, file.length - '.graphql'.length);
    const supergraph = buildSupergraphSchema(fs.readFileSync(path.join(testSupergraphDir, file), 'utf8'))[0];
    return {
      version,
      supergraph,
      api: supergraph.toAPISchema(),
    };
  }).filter(isDefined);
}

// This file is loaded by the `genTestSupergraph.ts` script to generate the test supergraph for the current version.
// But when it's called, jest won't be running so we need to skip everything after this (we could alternatively
// move the test supergraph generation code some other place, but it's convenient to have the subgraph definitions
// alongsides the tests themselves, and this a bit of duplication).
if (typeof describe !== 'undefined') {
  describe('works with supergraph generated by older versions', () => {
    expect.addSnapshotSerializer(astSerializer);
    expect.addSnapshotSerializer(queryPlanSerializer);

    const toTest = listTestSupergraphs();

    describe.each(toTest)(`handles supergraphs from $version`, ({supergraph, api}) => {
      let qp: QueryPlanner;

      test('can extract subgraphs and build the query planner', () => {
        qp = new QueryPlanner(supergraph);
      });

      test('can execute "me" query', () => {
        const operation = operationFromDocument(api, gql`
          {
            me {
              nickname
              reviews {
                rating
              }
            }
          }
        `);

        const plan = qp.buildQueryPlan(operation);
        expect(plan).toMatchInlineSnapshot(`
          QueryPlan {
            Parallel {
              Fetch(service: "accounts") {
                {
                  me {
                    nickname
                  }
                }
              },
              Fetch(service: "reviews") {
                {
                  me {
                    reviews {
                      rating
                    }
                  }
                }
              },
            },
          }
        `);
      });

      test('can execute "bestRatedProducts" query', () => {
        const operation = operationFromDocument(api, gql`
          {
            bestRatedProducts(limit: 10) {
              reviews {
                author {
                  nickname
                }
                rating
              }
              price {
                value
                currency
              }
              ... on Movie {
                length_minutes
              }
              ... on Book {
                avg_rating
              }
            }
          }
        `);

        const plan = qp.buildQueryPlan(operation);
        expect(plan).toMatchInlineSnapshot(`
          QueryPlan {
            Sequence {
              Fetch(service: "reviews") {
                {
                  bestRatedProducts(limit: 10) {
                    __typename
                    reviews {
                      author {
                        __typename
                        id
                      }
                      rating
                    }
                    ... on Book {
                      __typename
                      id
                      reviews {
                        rating
                      }
                    }
                    ... on Movie {
                      __typename
                      id
                    }
                  }
                }
              },
              Parallel {
                Flatten(path: "bestRatedProducts.@.reviews.@.author") {
                  Fetch(service: "accounts") {
                    {
                      ... on User {
                        __typename
                        id
                      }
                    } =>
                    {
                      ... on User {
                        nickname
                      }
                    }
                  },
                },
                Flatten(path: "bestRatedProducts.@") {
                  Fetch(service: "products") {
                    {
                      ... on Book {
                        __typename
                        id
                        reviews {
                          rating
                        }
                      }
                      ... on Movie {
                        __typename
                        id
                      }
                    } =>
                    {
                      ... on Book {
                        price {
                          value
                          currency
                        }
                        avg_rating
                      }
                      ... on Movie {
                        price {
                          value
                          currency
                        }
                        length_minutes
                      }
                    }
                  },
                },
              },
            },
          }
        `);
      });
    });
  });
}
