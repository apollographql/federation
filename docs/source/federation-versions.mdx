---
title: Federation version changelog
description: Understand changes between federation versions
---

## v2.3

**Additions**

* introduce [`@interfaceObject`](https://www.apollographql.com/docs/federation/federated-types/interfaces) directive - a directive that allows you to abstract an interface in isolation by declaring it locally as an object type. This enables you to contribute fields without needing to redefine all the interfaceâ€™s concrete implementation types.

```graphql
directive @interfaceObject on OBJECT
```

* support `@key` on interface definitions - while `@key` directive definition already defined `INTERFACE` as a valid location, this information wasn't used during composition. With introduction of `@interfaceObject` we now need to specify matching `@key` on abstract interfaces
**Note:** This directive was already available in earlier versions of federation, but it wasn't used during composition.


## v2.2

**Changes**

Composition now rejects `@shareable` on interface fields. The @shareable directive is about controlling if
multiple subgraphs can resolve a particular field, and as interface field are never directly resolved (it's their implementation that are), having @shareable on interface fields is not completely meaningful and was never meant to be supported.
If an existing subgraph does have a @shareable on an interface field, this will now be rejected,
but the @shareable can simply and safely be removed since it previously was ignored.

The `@shareable` directive has been [updated to be repeatable](https://github.com/apollographql/federation/pull/2175). This allows you to use in a type definition and in an extension of that type definition.

```graphql
directive @shareable repeatable on OBJECT | FIELD_DEFINITION
```


## v2.1

**Additions**

* introduce new [`@composeDirective`](https://www.apollographql.com/docs/federation/federated-types/federated-directives/#composedirective) - 
directive indicates to composition that all uses
of a particular custom type system directive in the subgraph schema should be preserved
in the supergraph schema (by default, composition omits most directives from the supergraph schema).

```graphql
directive @composeDirective(name: String!) repeatable on SCHEMA
```

Here's an example of how to use `@composeDirective`:

```graphql
extend schema
    @link(url: "https://specs.apollo.dev/link/v1.0")
    @link(url: "https://specs.apollo.dev/federation/v2.1", import: ["@composeDirective"])
    @link(url: "https://myspecs.dev/myDirective/v1.0", import: ["@myDirective", { name: "@anotherDirective", as: "@hello" }])
    # highlight-start
    @composeDirective(name: "@myDirective")
    @composeDirective(name: "@hello")
    # highlight-end

# highlight-start
directive @myDirective(a: String!) on FIELD_DEFINITION
directive @hello on FIELD_DEFINITION
# highlight-end
```

**Note:** like for federation directives, make sure to include the `@composeDirective` directive in the `import` list of the `@link` directive that points to the spec that defines the directive. You can see in our example above that, in addition to importing the federation directives, we are also importing `@myDirective` from `"https://myspecs.dev/myDirective/v1.0"`

## v2.0

**Directive changes**

Subgraph schemas "opt in" to Federation 2 features by applying the `@link` directive to the `schema` type, like so:

```graphql
extend schema
  @link(url: "https://specs.apollo.dev/federation/v2.0",
        import: ["@key", "@shareable"])
```

The `import` list of this definition must include each federation-specific directive that the subgraph schema uses. In the example above, the schema uses `@key` and `@shareable`.

For details on these directives as defined in Federation 2, see [Federation-specific GraphQL directives](./federated-types/federated-directives/).

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Description</th>
    </tr>
  </thead>

<tbody>
<tr>
<td>

##### `@key`

</td>
<td>

Added optional `resolvable` argument.

```graphql
directive @key(
  fields: FieldSet!,
  resolvable: Boolean = true # highlight-line
) repeatable on OBJECT | INTERFACE
```

</td>
</tr>

<tr>
<td>

##### `@shareable`

</td>
<td>

Introduced.

```graphql
directive @shareable on OBJECT | FIELD_DEFINITION
```

</td>
</tr>

<tr>
<td>

##### `@inaccessible`

</td>
<td>

Introduced.

```graphql
directive @inaccessible on
  | FIELD_DEFINITION
  | OBJECT
  | INTERFACE
  | UNION
  | ARGUMENT_DEFINITION
  | SCALAR
  | ENUM
  | ENUM_VALUE
  | INPUT_OBJECT
  | INPUT_FIELD_DEFINITION
```

</td>
</tr>

<tr>
<td>

##### `@override`

</td>
<td>

Introduced.

```graphql
directive @override(from: String!) on FIELD_DEFINITION
```

</td>
</tr>

<tr>
<td>

##### `@link`

</td>
<td>

Introduced.

```graphql
directive @link(
  url: String,
  as: String,
  for: link__Purpose,
  import: [link__Import]
) repeatable on SCHEMA
```

</td>
</tr>

<tr>
<td>

##### `@extends`, `@external`, `@provides`, `@requires`, `@tag`

</td>
<td>

No changes.

</td>
</tr>

</tbody>
</table>

**Subgraph changes**

<table>
  <thead>
    <tr>
      <th>Topic</th>
      <th>Description</th>
    </tr>
  </thead>

<tbody>
<tr>
<td>

Entities

</td>
<td>

* Entities no longer _originate_ in a subgraph. Instead, any number of subgraphs can define the same entity and _contribute fields_ to it.
* Multiple subgraphs _can_ contribute the same field to an entity, _if_ that field is marked as `@shareable` in every subgraph that defines it.
* Subgraphs no longer need to `extend` (or `@extends`) an entity whenever another subgraph already defines that entity.
* Each subgraph can apply any number of `@key` directives to an entity.
* Subgraphs _must_ no longer apply the `@external` directive to their `@key` fields.

</td>
</tr>

<tr>
<td>

Value types

</td>
<td>

* To define a value type with shared fields across multiple subgraphs, those shared fields must be marked as `@shareable` in every subgraph that defines them.
* Value type fields _can_ differ across subgraphs (in certain ways). For details, see [Differing shared fields](./federated-types/sharing-types#differing-shared-fields).

</td>
</tr>

<tr>
<td>

`Query` and `Mutation`

</td>
<td>

* More than one subgraph _can_ define the same field of the `Query` or `Mutation` type, _if_ that field is marked as `@shareable` in every subgraph that defines it.
* Subgraphs no longer need to apply the `extend` keyword (or the `@extends` directive) to the `Query` and `Mutation` types.

</td>
</tr>

</tbody>
</table>


## v1.1

**Directive changes**

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Description</th>
    </tr>
  </thead>

<tbody>
<tr>
<td>

##### `@tag`

</td>
<td>

Introduced.

```graphql
directive @tag(name: String!) repeatable on
  | FIELD_DEFINITION
  | INTERFACE
  | OBJECT
  | UNION
```

</td>
</tr>

</tbody>
</table>

## v1.0


**Directive changes**

For details on these directives as defined in Federation 1, see the [Federation 1 subgraph spec](/federation/v1/federation-spec).

<table>
  <thead>
    <tr>
      <th>Name</th>
      <th>Description</th>
    </tr>
  </thead>

<tbody>
<tr>
<td>

##### `@key`

</td>
<td>

Introduced.

```graphql
directive @key(fields: _FieldSet!) repeatable on OBJECT | INTERFACE
```

</td>
</tr>

<tr>
<td>

##### `@external`

</td>
<td>

Introduced.

```graphql
directive @external on FIELD_DEFINITION
```

</td>
</tr>

<tr>
<td>

##### `@requires`

</td>
<td>

Introduced.

```graphql
directive @requires(fields: _FieldSet!) on FIELD_DEFINITION
```

</td>
</tr>

<tr>
<td>

##### `@provides`

</td>
<td>

Introduced.

```graphql
directive @provides(fields: _FieldSet!) on FIELD_DEFINITION
```

</td>
</tr>

<tr>
<td>

##### `@extends`

</td>
<td>

Introduced.

```graphql
directive @extends on OBJECT | INTERFACE
```

</td>
</tr>

</tbody>
</table>

**Subgraph changes**

<table>
  <thead>
    <tr>
      <th>Topic</th>
      <th>Description</th>
    </tr>
  </thead>

<tbody>
<tr>
<td>

Entities

</td>
<td>

* Each entity _originates_ in exactly one subgraph and can be _extended_ in other subgraphs.
* An entity's originating subgraph _must_ apply _at least one_ `@key` directive to the entity definition.
* An extending subgraph must use the `extend` keyword (or the `@extends` directive) when defining another subgraph's entity.
* An extending subgraph must apply exactly one `@key` directive to any entity it extends. The `fields` of that `@key` must match a `@key` that's defined by the entity's originating subgraph.
* An extending subgraph must apply the `@external` directive to all `@key` fields of an entity it extends.
* If an entity field is defined in more than one subgraph, it must be marked as `@external` in all but _one_ subgraph.

</td>
</tr>

<tr>
<td>

Value types

</td>
<td>

* Each subgraph that defines a value type _must_ define that value type _identically_.

</td>
</tr>

<tr>
<td>

`Query` and `Mutation`

</td>
<td>

* More than one subgraph _cannot_ define the same field of the `Query` or `Mutation` type.
* Every subgraph must apply the `extend` keyword (or the `@extends` directive) to the `Query` and `Mutation` types.

</td>
</tr>

</tbody>
</table>
