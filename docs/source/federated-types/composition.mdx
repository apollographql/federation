---
title: Schema composition
description: In Apollo Federation
---

In Apollo Federation, _composition_ is the process of combining a set of [subgraph schemas](./overview/#subgraph-schemas) into a [supergraph schema](./overview/#supergraph-schema):

```mermaid
graph TB;
  serviceA[Subgraph<br/>schema<br/>A];
  serviceB[Subgraph<br/>schema<br/>B];
  serviceC[Subgraph<br/>schema<br/>C];
  composition[["üõ†<br/>Composition "]];
  supergraph{{"Supergraph schema<br/>(A + B + C + routing machinery)"}};
  serviceA & serviceB & serviceC --> composition;
  composition -- "(Composition succeeds)" --> supergraph;
  class composition tertiary;
```

The supergraph schema includes all of the type and field definitions from your subgraph schemas. It also includes metadata that enables your router to intelligently route incoming GraphQL operations across all of your different subgraphs.

## Supported methods

You can perform schema composition with any of the following methods:

### Automatically with GraphOS

With [managed federation](../managed-federation/overview/), Apollo GraphOS performs composition automatically whenever one of your subgraphs updates its published schema. This enables your running router to dynamically fetch an updated supergraph schema from Apollo as soon as it's available:

```mermaid
graph LR;
  subgraph "Your infrastructure"
  serviceA[Products<br/>subgraph];
  serviceB[Reviews<br/>subgraph];
  gateway([Router]);
  end
  subgraph "GraphOS"
    registry{{Apollo Schema<br/>Registry}};
    uplink{{Apollo<br/>Uplink}}
  end
  serviceA & serviceB -->|Publishes schema| registry;
  registry -->|Updates config| uplink;
  gateway -->|Polls for config changes| uplink;
  class registry secondary;
  class uplink secondary;
```

To learn how to perform composition with managed federation, see the [quickstart](../quickstart/studio-composition/).

<Note>

GraphOS also provides a [schema linter](/graphos/delivery/schema-linter) with [composition specific rules](/graphos/delivery/linter-rules#composition-rules) to help you follow best practices. You can set up schema checks for your graph in GraphOS Studio or perform one-off linting with the Rover CLI. Check out the [schema linting](/graphos/delivery/schema-linter) docs to learn more.

</Note>

### Manually with the Rover CLI

The [Rover CLI](https://www.apollographql.com/docs/rover/) supports a `supergraph compose` command that you can use to compose a supergraph schema from a collection of subgraph schemas:

```bash
rover supergraph compose --config ./supergraph-config.yaml
```

To learn how to install Rover and use this command, see the [quickstart](../quickstart/setup/#install-the-rover-cli).

## Breaking composition

Sometimes, your subgraph schemas might conflict in a way that causes composition to fail. This is called _breaking composition_.

For example, take a look at these two subgraph schemas:

<p style="margin-bottom: 0">‚ùå</p>
<CodeColumns>

```graphql {2} title="Subgraph A"
type Event @shareable {
  timestamp: String!
}
```

```graphql {2} title="Subgraph B"
type Event @shareable {
  timestamp: Int!
}
```

</CodeColumns>

One subgraph defines `Event.timestamp` as a `String`, and the other defines it as an `Int`. Composition doesn't know which type to use, so it fails.

<Note>

For examples of valid inconsistencies in field return types, see [Differing shared field return types](./sharing-types/#return-types).

</Note>

Breaking composition is a helpful feature of federation! Whenever a team modifies their subgraph schema, those changes might conflict with another subgraph. But that conflict won't affect your router, because composition fails to generate a new supergraph schema. It's like a compiler error that prevents you from running invalid code.

## Rules of composition
In Federation 2, your subgraph schemas must follow all of these rules to successfully compose into a supergraph schema:

- Multiple subgraphs can't define the same field on an object type, unless that field is [shareable](./sharing-types/#using-shareable).
- A shared field must have both a compatible return type and compatible argument types across each defining subgraph.
    - For examples of compatible and incompatible differences between subgraphs, see [Differing shared fields](./sharing-types/#differing-shared-fields).
- If multiple subgraphs define the same type, each field of that type must be resolvable by every valid GraphQL operation that includes it.
    - This rule is the most complex and the most essential to Federation 2. [Let's look at it more closely.](#unresolvable-field-example)

### Unresolvable field example

This example presents a field of a shared type that is not always resolvable (and therefore [breaks composition](#breaking-composition)).

Consider these subgraph schemas:

<p style="margin-bottom: 0">‚ùå</p>

<CodeColumns>

```graphql title="Subgraph A"
type Query {
  positionA: Position!
}

type Position @shareable {
  x: Int!
  y: Int!
}
```

```graphql title="Subgraph B"
type Query {
  positionB: Position!
}

type Position @shareable {
  x: Int!
  y: Int!
  z: Int!
}
```


</CodeColumns>

Note the following about these two subgraphs:

- They both define a shared `Position` type.
- They both define a top-level `Query` field that returns a `Position`.
- Subgraph B's `Position` includes a `z` field, whereas Subgraph A's definition only includes shared `x` and `y` fields.

Individually, these subgraph schemas are perfectly valid. However, if they're combined, they break composition. Why?

The composition process attempts to merge inconsistent type definitions into a single definition for the supergraph schema. In this case, the resulting definition for `Position` exactly matches Subgraph B's definition:

<p style="margin-bottom: 0">‚ùå</p>

```graphql title="Hypothetical supergraph schema"
type Query {
  # From A
  positionA: Position!
  # From B
  positionB: Position!
}

type Position {
  # From A+B
  x: Int!
  y: Int!
  # From B
  z: Int!
}
```

Based on this hypothetical supergraph schema, the following query should be valid:

```graphql {5}
query GetPosition {
  positionA {
    x
    y
    z # ‚ö†Ô∏è Can't be resolved! ‚ö†Ô∏è
  }
}
```

Here's our problem. Only Subgraph A can resolve `Query.positionA`, because Subgraph B doesn't define the field. But Subgraph A doesn't define `Position.z`!

If the router sent this query to Subgraph A, it would return an error. And without extra configuration, Subgraph B can't resolve a `z` value for a `Position` in Subgraph A. Therefore, `Position.z` is unresolvable for this query.

Composition recognizes this potential issue, and it fails. The hypothetical supergraph schema above would never actually be generated.

`Position.z` is an example of a field that is not always resolvable. So now, how do we make sure that such a field is always resolvable?

### Solutions for unresolvable fields

There are multiple solutions for making sure that a field of a shared type is always resolvable. Choose a solution based on your use case:

#### Define the field in every subgraph that defines the type.

If every subgraph that defines a type could resolve every field of that type without introducing complexity, a straightforward solution is to define and resolve all fields in all of those subgraphs:

<p style="margin-bottom: 0">‚úÖ</p>

<CodeColumns>

```graphql {4} title="Subgraph A"
type Position @shareable {
  x: Int!
  y: Int!
  z: Int
}
```

```graphql title="Subgraph B"
type Position @shareable {
  x: Int!
  y: Int!
  z: Int!
}
```

</CodeColumns>

In this case, if Subgraph A only cares about the `x` and `y` fields, its resolver for `z` can always return `null`.

This is a useful solution for shared types that encapsulate simple scalar data.

<Note>

You can use the `@inaccessible` directive to incrementally add a value type field to multiple subgraphs without breaking composition. [Learn more.](./sharing-types/#adding-new-shared-fields)

</Note>

#### Make the shared type an entity

<p style="margin-bottom: 0">‚úÖ</p>

<CodeColumns>

```graphql title="Subgraph A"
type User @key(fields: "id") {
  id: ID!
  name: String!
}
```

```graphql title="Subgraph B"
type User @key(fields: "id") {
  id: ID!
  age: Int!
}
```

</CodeColumns>

If you make a shared type an [entity](../entities/), different subgraphs can define any number of different fields for that type, as long as they all define key fields for it.

This is a useful solution when a type corresponds closely to an entry in a data store that one or more of your subgraphs has access to (e.g., a `Users` database).

## Merging types from multiple subgraphs

If a particular GraphQL type is defined differently by different subgraphs, composition uses one of two strategies to merge those definitions: _union_ or _intersection_.

- **Union**: The supergraph schema includes all parts of all subgraph definitions for the type.
- **Intersection**: The supergraph schema includes only the parts of the type that are present in every subgraph that defines the type.

The merging strategy that composition uses for a particular type depends on the type, as described below.

### Object, union, and interface types

Composition always uses the union strategy to merge object, union, and interface types.

Consider the following subgraph schemas:

<CodeColumns>

```graphql title="Subgraph A"
type User @key(fields: "id") {
  id: ID!
  name: String!
  email: String!
}

union Media = Book | Movie

interface BookDetails {
  title: String!
  author: String!
}
```

```graphql title="Subgraph B"
type User @key(fields: "id") {
  id: ID!
  age: Int!
}

union Media = Book | Podcast

interface BookDetails {
  title: String!
  numPages: Int
}
```

</CodeColumns>

When these subgraph schemas are composed, the composition process merges the three corresponding types by union. This results in the following type definitions in the supergraph schema:

```graphql title="Supergraph schema"
type User {
  id: ID!
  age: Int!
  name: String!
  email: String!
}

union Media = Book | Movie | Podcast

interface BookDetails {
  title: String!
  author: String!
  numPages: Int
}
```

Because composition uses the union strategy for these types, subgraphs can contribute distinct parts and guarantee that those parts will appear in the composed supergraph schema.

<Note>

If different subgraphs contribute different fields to an interface type, any object types that implement that interface must define all contributed fields from all subgraphs. Otherwise, composition fails.

</Note>

### Input types and field arguments

Composition always uses the intersection strategy to merge input types and field arguments. This ensures that the router never passes an argument to a subgraph that doesn't define that argument.

Consider the following subgraph schemas:

<CodeColumns>

```graphql title="Subgraph A"
input UserInput {
  name: String!
  age: Int
}

type Library @shareable {
  book(title: String, author: String): Book
}
```

```graphql title="Subgraph B"
input UserInput {
  name: String!
  email: String
}

type Library @shareable {
  book(title: String, section: String): Book
}
```

</CodeColumns>

These subgraphs define different fields for the `UserInput` input type, and they define different arguments for the `Library.book` field. After composition merges using intersection, the supergraph schema definitions look like this:

```graphql title="Supergraph schema"
input UserInput {
  name: String!
}

type Library {
  book(title: String): Book
}
```

As you can see, the supergraph schema includes only the input fields and arguments that both subgraphs define.

<Note>

If the intersection strategy would omit an input field or argument that is non-nullable, composition fails. This is because at least one subgraph requires that field or argument, and the router can't provide it if it's omitted from the supergraph schema.

When defining input types and field arguments in multiple subgraphs, make sure that every non-nullable field and argument is consistent in every subgraph. For examples, see [Arguments](sharing-types#arguments).

</Note>

### Enums

If an enum definition differs between subgraphs, the [composition strategy](#merging-types-from-multiple-subgraphs) depends on how the enum is used:

| Scenario | Strategy |
|----------|----------|
| The enum is used as the return type for at least one object or interface field. | [Union](#union) |
| The enum is used as the type for at least one field argument or input type field. | [Intersection](#intersection) |
| Both of the above are true. | All definitions must [match exactly](#exact-match) |

Examples of these scenarios are provided below.

#### Enum composition examples

##### Union

Consider these subgraph schemas:

<CodeColumns>

```graphql title="Subgraph A"
enum Color {
  RED
  GREEN
  BLUE
}

type Query {
  favoriteColor: Color
}
```

```graphql title="Subgraph B"
enum Color {
  RED
  GREEN
  YELLOW
}

type Query {
  currentColor: Color
}
```

</CodeColumns>

In this case, the `Color` enum is used as the return type of at least one object field. Therefore, composition merges the `Color` enum by union, so that all possible subgraph return values are valid.

This results in the following type definition in the supergraph schema:

```graphql title="Supergraph schema"
enum Color {
  RED
  GREEN
  BLUE
  YELLOW
}
```

##### Intersection

Consider these subgraph schemas:

<CodeColumns>

```graphql title="Subgraph A"
enum Color {
  RED
  GREEN
  BLUE
}

type Query {
  products(color: Color): [Product]
}
```

```graphql title="Subgraph B"
enum Color {
  RED
  GREEN
  YELLOW
}

type Query {
  images(color: Color): [Image]
}
```

</CodeColumns>

In this case, the `Color` enum is used as the type of at least one field argument (or input type field). Therefore, composition merges the `Color` enum by intersection, so that subgraphs never receive a client-provided enum value that they don't support.

This results in the following type definition in the supergraph schema:

```graphql title="Supergraph schema"
# BLUE and YELLOW are removed via intersection
enum Color {
  RED
  GREEN
}
```

##### Exact match

Consider these subgraph schemas:

<p style="margin-bottom: 0">‚ùå</p>

<CodeColumns>

```graphql title="Subgraph A"
enum Color {
  RED
  GREEN
  BLUE
}

type Query {
  favoriteColor: Color
}
```

```graphql title="Subgraph B"
enum Color {
  RED
  GREEN
  YELLOW
}

type Query {
  images(color: Color): [Image]
}
```

</CodeColumns>

In this case, the `Color` enum is used as both:

- The return type of at least one object field
- The type of at least one field argument (or input type field)

Therefore, the definition of the `Color` enum must match exactly in every subgraph that defines it. An exact match is the only scenario that enables union and intersection to produce the same result.

The subgraph schemas above do not compose, because their definitions of the `Color` enum differ.

## Directives

Composition handles a directive differently depending on whether it's an "executable" directive or a "type system" directive.

### Executable directives

Executable directives are intended to be used by clients in their queries. They are applied to one or more of the [executable directive locations](http://spec.graphql.org/June2018/#ExecutableDirectiveLocation). For example, you might have a directive definition of `directive @lowercase on FIELD`, which a client could use in their query like so:

```graphql
query {
  getSomeData {
    someField @lowercase
  }
}
```

An executable directive is composed into the supergraph schema only if all of the following conditions are met:

- The directive is defined in all subgraphs.
- The directive is defined identically in all subgraphs.
- The directive is not included in any [`@composeDirective`](./federated-directives#composedirective) directives.

### Type system directives

Type system directives help define the structure of the schema and are not intended for use by clients. They are applied to one or more of the [type system directive locations](http://spec.graphql.org/June2018/#TypeSystemDirectiveLocation).

These directives are not composed into the supergraph schema, but they can still provide information to the router via the [`@composeDirective`](./federated-directives#composedirective) directive.
