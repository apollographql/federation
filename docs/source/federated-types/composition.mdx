---
title: Schema composition
---

In Apollo Federation, **composition** is the process of combining a set of [subgraph schemas](./overview/#subgraph-schemas) into a [supergraph schema](./overview/#supergraph-schema):

```mermaid
graph TB;
  serviceA[Subgraph<br/>schema<br/>A];
  serviceB[Subgraph<br/>schema<br/>B];
  serviceC[Subgraph<br/>schema<br/>C];
  composition[["üõ†<br/>Composition "]];
  supergraph{{"Supergraph schema<br/>(A + B + C + routing machinery)"}};
  serviceA & serviceB & serviceC --> composition;
  composition -- "(Composition succeeds)" --> supergraph;
  class composition tertiary;
```

The supergraph schema includes all of the type and field definitions from your subgraph schemas. It's what enables your gateway to intelligently route incoming GraphQL operations across all of your different subgraphs.

## Supported methods

You can perform schema composition with any of the following methods:

### Manually with the Rover CLI

The [Rover CLI](https://www.apollographql.com/docs/rover/) supports a `supergraph compose` command that you can use to compose a supergraph schema from a collection of subgraph schemas:

```bash
rover supergraph compose --config ./supergraph-config.yaml
```

> ‚ö†Ô∏è **Important:** To perform Federation 2 composition with Rover, the YAML `--config` file you provide must include the following line:
>
> ```yaml title="supergraph-config.yaml"
> federation_version: 2
> ```
>
> Otherwise, Rover uses Federation 1 composition.

To learn how to install Rover and use this command, see the [Quickstart](../quickstart/setup/#1-install-the-rover-cli).

### Automatically with managed federation

With [managed federation](../managed-federation/overview/), Apollo performs composition automatically whenever one of your subgraphs updates its registered schema. This enables your running gateway to dynamically fetch an updated supergraph schema from Apollo as soon as it's available:

```mermaid
graph LR;
  subgraph "Your infrastructure"
  serviceA[Products<br/>subgraph];
  serviceB[Reviews<br/>subgraph];
  gateway([Gateway]);
  end
  subgraph "Apollo cloud"
    registry{{Apollo Schema<br/>Registry}};
    uplink{{Apollo<br/>Uplink}}
  end
  serviceA & serviceB -->|Publishes schema| registry;
  registry -->|Updates config| uplink;
  gateway -->|Polls for config changes| uplink;
  class registry secondary;
  class uplink secondary;
```

To learn how to perform composition with managed federation, see the [Quickstart](../quickstart/studio-composition/).

## Breaking composition

Sometimes, your subgraph schemas might _conflict_ in a way that causes composition to fail. This is called **breaking composition**.

For example, take a look at these two subgraph schemas:

<p style="margin-bottom: 0">‚ùå</p>
<CodeColumns>

```graphql {2} title="Subgraph A"
type Event {
  timestamp: String!
}
```

```graphql {2} title="Subgraph B"
type Event {
  timestamp: Int!
}
```

</CodeColumns>

One subgraph defines `Event.timestamp` as a `String`, and the other defines it as an `Int`. Composition doesn't know which type to use, so it fails.

> For examples of _valid_ inconsistencies in field return types, see [Differing shared field return types](./sharing-types/#return-types).

Breaking composition is a helpful feature of federation! Whenever a team modifies their subgraph schema, those changes might conflict with _another_ subgraph. But that conflict won't affect your gateway, because composition fails to generate a new supergraph schema. It's like a compiler error that prevents you from running invalid code.

## Rules of composition
In Federation 2, your subgraph schemas must follow **all** of these rules to successfully compose into a supergraph schema:

* Multiple subgraphs can't define the same field on an object type, _unless_ that field is [shareable](./sharing-types/#using-shareable).
* A shared field must have both a compatible return type _and_ compatible argument types across each defining subgraph.
    * For examples of compatible and incompatible differences between subgraphs, see [Differing shared fields](./sharing-types/#differing-shared-fields).
* If multiple subgraphs define the same type, each field of that type must be **resolvable** by _every valid GraphQL operation that includes it_.
    * This rule is the most complex and the most essential to Federation 2. [Let's look at it more closely.](#unresolvable-field-example)

### Unresolvable field example

This example presents a field of a shared type that is _not_ always resolvable (and therefore [breaks composition](#breaking-composition)).

Consider these subgraph schemas:

<p style="margin-bottom: 0">‚ùå</p>

<CodeColumns>

```graphql title="Subgraph A"
type Query {
  positionA: Position!
}

type Position @shareable {
  x: Int!
  y: Int!
}
```

```graphql title="Subgraph B"
type Query {
  positionB: Position!
}

type Position @shareable {
  x: Int!
  y: Int!
  z: Int!
}
```


</CodeColumns>

Note the following about these two subgraphs:

* They both define a shared `Position` type.
* They both define a top-level `Query` field that returns a `Position`.
* Subgraph B's `Position` includes a `z` field, whereas Subgraph A's definition only includes shared `x` and `y` fields.

Individually, these subgraph schemas are perfectly valid. However, if they're combined, **they break composition**. Why?

The composition process attempts to merge inconsistent type definitions into a _single_ definition for the supergraph schema. In this case, the resulting definition for `Position` exactly matches Subgraph B's definition:

<p style="margin-bottom: 0">‚ùå</p>

```graphql title="Hypothetical supergraph schema"
type Query {
  # From A
  positionA: Position!
  # From B
  positionB: Position!
}

type Position {
  # From A+B
  x: Int!
  y: Int!
  # From B
  z: Int!
}
```

Based on this hypothetical supergraph schema, the following query _should_ be valid:

```graphql {5}
query GetPosition {
  positionA {
    x
    y
    z # ‚ö†Ô∏è Can't be resolved! ‚ö†Ô∏è
  }
}
```

**Here's our problem.** Only Subgraph A can resolve `Query.positionA`, because Subgraph B doesn't define the field. But Subgraph A _doesn't_ define `Position.z`!

If the gateway sent this query to Subgraph A, it would return an error. And without extra configuration, Subgraph B can't resolve a `z` value for a `Position` in Subgraph A. Therefore, `Position.z` is **unresolvable** for this query.

Composition recognizes this potential issue, and it fails. The hypothetical supergraph schema above would never actually be generated.

`Position.z` is an example of a field that is _not_ always resolvable. So now, how do we make sure that such a field _is_ always resolvable?

### Solutions for unresolvable fields

There are multiple solutions for making sure that a field of a shared type is always resolvable. Choose a solution based on your use case:

#### Define the field in every subgraph that defines the type.

If every subgraph that defines a type _could_ resolve every field of that type without introducing complexity, a straightforward solution is to define and resolve all fields in all of those subgraphs:

<p style="margin-bottom: 0">‚úÖ</p>

<CodeColumns>

```graphql {4} title="Subgraph A"
type Position @shareable {
  x: Int!
  y: Int!
  z: Int
}
```

```graphql title="Subgraph B"
type Position @shareable {
  x: Int!
  y: Int!
  z: Int!
}
```

</CodeColumns>

In this case, if Subgraph A only cares about the `x` and `y` fields, its resolver for `z` can always return `null`.

This is a useful solution for shared types that encapsulate simple scalar data.

> You can use the `@inaccessible` directive to incrementally add a value type field to multiple subgraphs _without_ breaking composition. [Learn more.](./sharing-types/#adding-new-shared-fields)

#### Make the shared type an entity.

<p style="margin-bottom: 0">‚úÖ</p>

<CodeColumns>

```graphql title="Subgraph A"
type User @key(fields: "id") {
  id: ID!
  name: String!
}
```

```graphql title="Subgraph B"
type User @key(fields: "id") {
  id: ID!
  age: Int!
}
```

</CodeColumns>

If you make a shared type an [entity](../entities/), different subgraphs can define any number of different fields for that type, as long as they all define **key fields** for it.

This is a useful solution when a type corresponds closely to an entry in a data store that one or more of your subgraphs has access to (e.g., a `Users` database).

## Merging types during composition

During composition, two strategies are used under the hood to merge different schema types: union and intersection. 

* The **union strategy** incorporates _all_ of a type's fields, from each subgraph, into the supergraph schema. 
* The **intersection strategy** incorporates only the fields (or field arguments) that _every_ subgraph has _in common_ into the supergraph schema. 

The resulting supergraph schema will change depending on which merging strategy composition uses. 

### Merging objects, unions, and interfaces

Composition uses the union strategy to merge object, union, and interface types. The union strategy incorporates _all_ of a type's fields, from each subgraph, into the supergraph schema. 

Consider the following subgraph schemas:

<CodeColumns>

```graphql title="Subgraph A"
type User @key(fields: "id") {
  id: ID!
  name: String!
  email: String!
}

union Media = Book | Movie

interface BookInput {
  title: String!
  author: String!
}
```

```graphql title="Subgraph B"
type User @key(fields: "id") {
  id: ID!
  age: Int!
}

union Media = Book | Podcast

interface BookInput {
  title: String!
  numPages: Int
}
```

<></>

</CodeColumns>

When the above subgraphs are composed, the composition process will merge corresponding types using the union strategy resulting in the following supergraph schema:

```graphql title="Supergraph schema"
type User {
  id: ID!
  age: Int!
  name: String!
  email: String!
}

union Media = Book | Movie | Podcast

interface BookInput {
  title: String!
  author: String!
  numPages: Int
}
```

The union strategy enables the gateway to avoid worrying about which subgraph contains a field's information until runtime. At runtime, the gateway can use its resolvers to pick and choose the information it needs from its subgraphs before returning that data to the client. 

### Merging input types and field arguments

Composition uses the intersection strategy to merge both input types and field arguments. The intersection strategy incorporates only the fields or arguments that _every_ subgraph has _in common_ into the supergraph schema. 

Consider the following subgraph schemas:

<CodeColumns>

```graphql title="Subgraph A"
input UserInput {
  name: String!
  age: Int
}

type Library @shareable {
  findBook(title: String, author: String): Book
}
```

```graphql title="Subgraph B"
input UserInput {
  name: String!
  email: String
}

type Library @shareable {
  findBook(title: String, section: String): Book
}

```

</CodeColumns>

The intersection merging strategy only incorporates the matching fields between input types. This means any `input` field that isn't in every subgraph gets left out of the supergraph schema. The same is true for field arguments:

```graphql title="Supergraph schema"
input UserInput {
  name: String!
}

type Library {
  # field arguments are composed via the intersection merging strategy
  findBook(title: String): Book
}
```

> When defining input types and field arguments in multiple subgraphs, ensure that every non-nullable field (and field argument) is consistent in _every subgraph_. Otherwise, if any subgraphs are missing a non-nullable input field (or field argument) your supergraph schema won't contain that field! See [Arguments](sharing-types#arguments) for examples.  

The intersection strategy ensures your gateway knows that all of your subgraphs can process the field arguments in an incoming GraphQL operation. 

### Merging enums

Enums are the only type that composition can merge using either [union](#merging-objects-unions-and-interfaces) or [intersection](#merging-input-types-and-field-arguments). Composition's merging strategy for an enum is dictated by how your subgraphs use that enum. 

For example, if you define an `enum` type in multiple subgraphs, like so:

<CodeColumns>

```graphql title="Subgraph A"
enum Color {
  RED
  GREEN
  BLUE
}
```

```graphql title="Subgraph B"
enum Color {
  RED
  CYAN
  MAGENTA
  YELLOW
}
```

</CodeColumns>

Composition will use the [union merging strategy](#merging-types-during-composition) to incorporate all of your enum's fields, resulting in the following supergraph schema:

```graphql title="Supergraph schema"
enum Color {
  RED
  GREEN
  BLUE
  CYAN
  MAGENTA
  YELLOW
}
```

However, if you use your enum as either a field argument or as an input field's return type, the composition process uses the [intersection merging strategy](#merging-types-during-composition) for that enum.

Let's say we'd like to use our previous `enum` as an argument for a new field, like so:

<CodeColumns>

```graphql title="Subgraph A"
enum Color {
  RED
  GREEN
  BLUE
}

type ColorQuery {
  avatar(borderColor: Color): String
}
```

```graphql title="Subgraph B"
enum Color {
  RED
  CYAN
  MAGENTA
  YELLOW
}
```

</CodeColumns>

The composition process will only incorporate the _shared_ values between our two `enum` type definitions in the newly composed supergraph schema:

```graphql title="Supergraph schema"
enum Color {
  RED
}

type ColorQuery {
  avatar(borderColor: Color): String
}
```

If we'd like all of our enum's possible values to be present in the supergraph schema, we can ensure our `enum` has the same values in every subgraph:

<CodeColumns>

```graphql title="Subgraph A"
enum Color {
  RED
  GREEN
  BLUE
  CYAN
  MAGENTA
  YELLOW
}

type ColorQuery {
  avatar(borderColor: Color): String
}
```

```graphql title="Subgraph B"
enum Color {
  RED
  GREEN
  BLUE
  CYAN
  MAGENTA
  YELLOW
}
```

</CodeColumns>

Now, even though composition is merging via intersection, the resulting supergraph schema will have all of our `enum`'s values:

```graphql title="Supergraph schema"
enum Color {
  RED
  GREEN
  BLUE
  CYAN
  MAGENTA
  YELLOW
}

type ColorQuery {
  avatar(borderColor: Color): String
}
```

This advice also applies to using an enum as an input field's return type:

<CodeColumns>

```graphql title="Subgraph A"
enum AvailableAnimal {
  CAT
  DOG
  RABBIT
}

input AnimalInfo {
  name: String
  species: AvailableAnimal
}
```

```graphql title="Subgraph B"
enum AvailableAnimal {
  CAT
  DOG
  RABBIT
}
```

</CodeColumns>

By ensuring all of our subgraphs define an enum the same way, the composition process will include all of our enum's values:

```graphql title="Supergraph schema"
enum AvailableAnimal {
  CAT
  DOG
  RABBIT
}

input AnimalInfo {
  name: String
  species: AvailableAnimal
}
```

