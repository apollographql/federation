---
title: Sharing types and fields
sidebar_title: Sharing types and fields
description: Sharing types and fields across multiple subgraphs
---

import { CodeColumns } from 'gatsby-theme-apollo-docs';

> ⚠️ Sharing fields across multiple subgraphs has changed significantly in Federation 2. For a summary of these changes, [see what's new](/federation-2/new-in-federation-2/#type-and-field-sharing). For more information about value types within Federation 1, you can view the [previous version of this article here](https://www.apollographql.com/docs/federation/v1/value-types/).

In a federated graph it's common to want to share and reuse a GraphQL type across multiple [subgraphs](./subgraphs/). 

For example, you might define and reuse a generic `Position` type across multiple subgraphs:

```graphql
type Position {
  x: Int!
  y: Int!
}
```

This article describes how to define the fields in a type as shareable in a federated graph, along with scenarios where improper sharing can [break composition](./composition/#breaking-composition).

## The @shareable directive

The `@shareable` directive indicates that a particular field can be resolved by more than one subgraph. This enables you to share all of the fields on a **type**, or selected individual **fields**, across multiple subgraphs. 

To enable the `@shareable` directive you must first add the following snippet to the top of **each subgraph** that will have one or more shareable fields:

```
extend schema
    @link(url: "https://specs.apollo.dev/federation/v2.0",
       import: ["@shareable"])
```

You can now add `@shareable` to the fields or types that you'd like to share across subgraphs:

<CodeColumns>

```graphql
# Subgraph A
type Position @shareable {
  x: Int!
  y: Int!
}
```

```graphql{4-5}
# Subgraph B
type Position @shareable {
  x: Int!
  y: Int!
}
```

> If a field is marked `@shareable` in _any_ subgraph, it must be marked `@shareable` or `@external` in _every_ subgraph that defines it. Otherwise, composition fails.

When you apply the `@shareable` directive to a type you are effectively making all the fields within that type shared. By default fields are not shared unless you directly make them so using `@shareable` or another direction such as  `@key` or `@requires`.

</CodeColumns>

Note that **each type** you are sharing must have the `@shareable` directive. 

You can also choose to share individual fields if you don't need to share the entire type:

<CodeColumns>

```graphql
# Subgraph A
type Book {
  title: String! @sharable # These fields are shared across subgraphs 
  author: String!
}
```

```graphql
# Subgraph B
type Book {
  title: String!  @sharable # These fields are shared across subgraphs 
  numPages: Int!
}
```

</CodeColumns>


Using our previous example, you can share the fields for both of the `Error` interface and the `ErrorCode` enum across multiple subgraphs by adding the `@shareable` directive:

</CodeColumns>



You can also choose to instead apply `@sharable` to individual fields to share just those fields with other subgraphs. 

These types don't "originate" in a particular subgraph. Instead, they are _shared_ across all of the subgraphs that use them. Types and their fields can be shared across subgraphs, even if _certain_ details differ between definitions. 



### Valid shared field differences between subgraphs

Types and their fields can be shared across subgraphs, even if _certain_ details differ between definitions. 

For example, look at how our `Position` type and `Color` types differ below:

<CodeColumns>

```graphql
# Subgraph A
type Position @shareable {
  x: Int!
  y: Int!
}
```

```graphql
# Subgraph B
type Position @shareable {
  x: Int
  y: Int
  z: Int!   # Not in A
}
```

</CodeColumns>

Shared fields can differ in a few ways:
* The return type of a field can vary in nullability (`String` / `String!`).
* Types can omit fields that are included in _other_ subgraphs, as long as every field in your supergraph is always **resolvable**. (For details, see [Rules of composition](../federated-types/composition/#rules-of-composition).)


### Varying field return types

Let's say two subgraphs both define an `Event` object type with a `timestamp` field:

<p style="margin-bottom: 0">❌</p>

<CodeColumns>

```graphql{3}
# Subgraph A
type Event {
  timestamp: Int!
}
```

```graphql{3}
# Subgraph B
type Event {
  timestamp: String!
}
```

</CodeColumns>

Subgraph A's `timestamp` returns an `Int`, and Subgraph B's returns a `String`. **This is invalid.** When composition attempts to generate an `Event` type for the supergraph schema, it fails due to an unresolvable conflict between the two `timestamp` definitions.

Next, look at these varying definitions for the `Position` object type:

<p style="margin-bottom: 0">✅</p>

<CodeColumns>

```graphql
# Subgraph A
type Position @shareable {
  x: Int!
  y: Int!
}
```

```graphql
# Subgraph B
type Position @shareable {
  x: Int
  y: Int
}
```

</CodeColumns>

The `x` and `y` fields are _non-nullable_ in subgraph A, but they're _nullable_ in subgraph B. **This is valid!** Composition recognizes that it can use the following definition for `Position` in the supergraph schema:

<CodeColumns>

```graphql
# Supergraph schema "shares" the fields between subgraphs
type Position {
  x: Int
  y: Int
}
```

</CodeColumns>

This definition works for querying Subgraph A, because Subgraph A's definition is _more restrictive_ than this (a non-nullable value is always valid for a nullable field). In this case, composition **coerces** Subgraph A's `Position` fields to satisfy the reduced restrictiveness of Subgraph B.

> Note that Subgraph A's actual subgraph schema is _not_ modified. Within Subgraph A, `x` and `y` remain non-nullable.

### Omitting fields

Look at these two definitions of a `Position` object type:

<p style="margin-bottom: 0">⚠️</p>

<CodeColumns>

```graphql
# Subgraph A
type Position {
  x: Int!
  y: Int!
}
```

```graphql
# Subgraph B
type Position {
  x: Int!
  y: Int!
  z: Int!
}
```

<></>

</CodeColumns>

Subgraph B defines a `z` field, but Subgraph A doesn't. In this case, when composition generates the `Position` type for the supergraph schema, it includes all three fields:

<CodeColumns>

```graphql
# Supergraph schema
type Position {
  x: Int!
  y: Int!
  z: Int!
}
```

<></>

</CodeColumns>


**This definition works for Subgraph B, but it presents a problem for Subgraph A.** Let's say Subgraph A defines the following `Query` type:

<CodeColumns>

```graphql
# Subgraph A
type Query {
  currentPosition: Position!
}
```

<></>

</CodeColumns>

According to the hypothetical supergraph schema, the following query is valid against the supergraph:

<p style="margin-bottom: 0">❌</p>

<CodeColumns>

```graphql
query GetCurrentPosition {
  currentPosition {
    x
    y
    z # ⚠️ Unresolvable! ⚠️
  }
}
```

<></>

</CodeColumns>

And here's the problem: if Subgraph B _doesn't_ define `Query.currentPosition`, this query _must_ be executed on Subgraph A. But Subgraph A is missing the `Position.z` field, so that field is **unresolvable**!

**Composition recognizes this potential problem, and it fails with an error.** So how do we fix it? Check out [Solutions for unresolvable fields](./composition/#solutions-for-unresolvable-fields).

## Enums and unions

In Federation 2, enum and union type definitions can differ between subgraphs:

<CodeColumns>

```graphql
# Subgraph A
union Media = Book | Movie

enum Color {
  RED
  GREEN
  BLUE
}
```

```graphql
# Subgraph B
union Media = Book | Podcast

enum Color {
  CYAN
  MAGENTA
  YELLOW
}
```

</CodeColumns>

Composition logic _merges_ these definitions in your supergraph schema:

```graphql
# Supergraph schema
union Media = Book | Movie | Podcast

enum Color {
  RED
  GREEN
  BLUE
  CYAN
  MAGENTA
  YELLOW
}
```

This can be useful when different subgraphs are responsible for different subsets of a particular set of related types or values.
