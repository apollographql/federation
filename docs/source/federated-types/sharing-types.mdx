---
title: Sharing types and fields
sidebar_title: Sharing types and fields
description: Sharing types and fields across multiple subgraphs
---

import { CodeColumns } from 'gatsby-theme-apollo-docs';

> ⚠️ The model of sharing fields across multiple subgraphs has changed significantly in Federation 2. For a summary of these changes, [see what's new](/federation-2/new-in-federation-2/#type-and-field-sharing). 
>
>For more information about using value types in Federation 1, you can view the [previous version of this article here](https://github.com/apollographql/federation/blob/release-2.0.0-alpha.2-followup/docs/source/federated-types/value-types.mdx).

In a federated graph, it's common to want to reuse a GraphQL type in multiple [subgraphs](./subgraphs/). 

For example, suppose you want to define the same generic `Position` type in different subgraphs:

```graphql
type Position {
  x: Int!
  y: Int!
}
```

This article describes how to share an object type's fields in a federated graph, allowing multiple subgraphs to **redefine** and **resolve** those shared fields. 

## Using `@shareable`

The `@shareable` directive enables multiple subgraphs to resolve a particular field or set of fields in multiple subgraphs.

The `@shareable` directive is new in Federation 2, so to enable it you first need to tell your subgraphs that they are using a Federation 2 schema (otherwise your schema will be treated as a [Federation 1 schema during composition](../federation-2/moving-to-federation-2/#2-use-new-composition-logic)).

To enable the `@shareable` directive, you must first add the following snippet to the top of **each subgraph file** that will contain a shareable field:

```graphql
extend schema
    @link(url: "https://specs.apollo.dev/federation/v2.0",
       import: ["@key", "@requires", "@shareable"])
```

Now you can apply the `@shareable` directive to types or individual fields within types that you want to share across multiple subgraphs:

<CodeColumns>

```graphql{2}
# Subgraph A
type Position @shareable {
  x: Int!
  y: Int!
}
```

```graphql{2}
# Subgraph B
type Position @shareable {
  x: Int!
  y: Int!
}
```
<></>

</CodeColumns>

> If a type or field is marked `@shareable` in _any_ subgraph, it must be marked `@shareable` or [`@external`](../federation-spec/#external) in _every_ subgraph that defines it. Otherwise, composition fails.

Adding the `@shareable` directive to a type is a shortcut to sharing every field within that type. You can also share individual fields, like so:

<CodeColumns>

```graphql{3}
# Subgraph A
type Food {
  name: String! @sharable
  cost: Int!
}
```

```graphql{3}
# Subgraph B
type Food {
  name: String!  @sharable
  inStock: Boolean!
}
```

<></>

</CodeColumns>

As well as letting you redefine a field in multiple subgraphs, the `@shareable` directive allows multiple subgraphs to resolve those shared fields. So in the example above, both subgraphs A and B can resolve the shared `Food.name` field. 

> ⚠️ **Important:** If multiple subgraphs can resolve a field, **make sure each subgraph's resolver for that field behaves identically.** Otherwise, queries might return inconsistent results depending on which subgraph resolves the field.

If you'd like to learn how shared fields can differ across subgraphs see, [Varying shared fields](#varying-shared-fields)

## Explicit sharing vs. implicit sharing

By default in Federation 2 schemas, **types** are shared across multiple subgraphs but **fields** are not. 

This means types are do not need to be explicitly shared in order for you add fields to them across subgraphs. 

Let's look at a few examples to illustrate this:

<p style="margin-bottom: 0">✅</p>

<CodeColumns>

```graphql{3}
# Subgraph A
type Date {
  month: Int
}
```

```graphql{3}
# Subgraph B
type Date {
  year: Int
}
```

</CodeColumns>

Under the hood Federation 2 will merge these types together, allowing Subgraph A to resolve `Date.month` and Subgraph B to resolve `Date.year`. 

Building  redefine a non-shared field in different subgraphs. 

Take this example:

<p style="margin-bottom: 0">❌</p>

<CodeColumns>

```graphql{3}
# Subgraph A
type Product {
  id: ID!
  name: String!
  price: Int
}
```

```graphql{3}
# Subgraph B
type Product {
  id: ID!
  name: String!
  price: Int
}
```

</CodeColumns>

Attempting to compose these two subgraph schemas together will [break composition](./composition/#breaking-composition). This is because the gateway doesn't know _which subgraph_ is responsible for resolving `Product`'s fields.

In the above example, if we'd like both Subgraph A _and_ Subgraph B to be able to resolve the fields for `Product` we can [share](#using-shareable) that type:

<p style="margin-bottom: 0">✅</p>

<CodeColumns>

```graphql{2}
# Subgraph A
type Product @shareable {
  id: ID!
  name: String!
  price: Int
}
```

```graphql{2}
# Subgraph A
type Product @shareable {
  id: ID!
  name: String!
  price: Int
}
```

</CodeColumns>

Now either subgraph A or B can resolve the fields for the `Date` type, and our subgraph schema will successfully compose into a supergraph schema.

If you instead wanted Subgraph A to resolve it's own fields, or vice versa, you could define `Product` as an [entity](../entities) allowing each subgraph to resolve it's own fields.

## Varying shared fields

Shared fields can differ between subgraphs in certain ways:
* The return type of a field can vary in nullability (`String` / `String!`).
  * A field's return type can't vary in its core type (`Int` vs. `String`) or in whether it returns a list (`Int` vs. `[Int]`).
* A field can be omitted from a subgraph entirely if that field is always [resolvable](../federated-types/composition/#rules-of-composition).

For example, take a look at the shared `Food` types below:

<CodeColumns>

```graphql{4}
# Subgraph A
type Food @sharable {
  name: String!
  cost: Int!
}
```

```graphql{4,5}
# Subgraph B
type Food @sharable {
  name: String!  
  cost: Int # Nullable
  inStock: Boolean! # Not in A
}
```

</CodeColumns>

The above shared `Food` types differ in the nullability of their fields _and_ the fields included in each type. 

### Differing return types

Let's say two subgraphs both define an `Event` object type with a `timestamp` field:

<p style="margin-bottom: 0">❌</p>

<CodeColumns>

```graphql{3}
# Subgraph A
type Event @shareable {
  timestamp: Int!
}
```

```graphql{3}
# Subgraph B
type Event @shareable {
  timestamp: String!
}
```

</CodeColumns>

Subgraph A's `timestamp` returns an `Int`, and Subgraph B's returns a `String`. **This is invalid.** When composition attempts to generate an `Event` type for the supergraph schema, it fails due to an unresolvable conflict between the two `timestamp` field definitions.

Next, look at these varying definitions for the `Position` object type:

<p style="margin-bottom: 0">✅</p>

<CodeColumns>

```graphql
# Subgraph A
type Position @shareable {
  x: Int!
  y: Int!
}
```

```graphql
# Subgraph B
type Position @shareable {
  x: Int
  y: Int
}
```

</CodeColumns>

The `x` and `y` fields are _non-nullable_ in subgraph A, but they're _nullable_ in subgraph B. **This is valid!** Composition recognizes that it can use the following definition for `Position` in the supergraph schema:


```graphql
# Supergraph schema "shares" the fields between subgraphs
type Position {
  x: Int
  y: Int
}
```

This definition works for querying Subgraph A, because Subgraph A's definition is _more restrictive_ than this (a non-nullable value is always valid for a nullable field). In this case, composition **coerces** Subgraph A's `Position` fields to satisfy the reduced restrictiveness of Subgraph B.

> Note that Subgraph A's actual subgraph schema is _not_ modified. Within Subgraph A, `x` and `y` remain non-nullable.

### Omitting fields

Look at these two definitions of a `Position` object type:

<p style="margin-bottom: 0">⚠️</p>

<CodeColumns>

```graphql
# Subgraph A
type Position @shareable {
  x: Int!
  y: Int!
}
```

```graphql
# Subgraph B
type Position @shareable {
  x: Int!
  y: Int!
  z: Int!
}
```

<></>

</CodeColumns>

Subgraph B defines a `z` field, but Subgraph A doesn't. In this case, when composition generates the `Position` type for the supergraph schema, it includes all three fields:

<CodeColumns>

```graphql
# Supergraph schema
type Position {
  x: Int!
  y: Int!
  z: Int!
}
```

<></>

</CodeColumns>

**This definition works for Subgraph B, but it presents a problem for Subgraph A.** Let's say Subgraph A defines the following `Query` type:

<CodeColumns>

```graphql
# Subgraph A
type Query {
  currentPosition: Position!
}
```

<></>

</CodeColumns>

According to the hypothetical supergraph schema, the following query is valid against the supergraph:

<p style="margin-bottom: 0">❌</p>

<CodeColumns>

```graphql
query GetCurrentPosition {
  currentPosition {
    x
    y
    z # ⚠️ Unresolvable! ⚠️
  }
}
```

<></>

</CodeColumns>

And here's the problem: if Subgraph B _doesn't_ define `Query.currentPosition`, this query _must_ be executed on Subgraph A. But Subgraph A is missing the `Position.z` field, so that field is **unresolvable**!

**Composition recognizes this potential problem, and it fails with an error.** So how do we fix it? Check out [Solutions for unresolvable fields](./composition/#solutions-for-unresolvable-fields).

