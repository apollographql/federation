---
title: Using the @provides Directive
subtitle: Optimize query performance by resolving fields from specific query paths
description: Learn how to use the `@provides` directive to optimize query performance in Apollo Federation. Understand common patterns and when to use this directive.
---

<Note>

For basic syntax and directive reference, see the [`@provides` directive reference](/graphos/schema-design/federated-schemas/reference/directives#provides). To choose between `@shareable` and `@provides`, see [Resolve another subgraph's fields](/graphos/schema-design/federated-schemas/entities/resolve-another-subgraphs-fields).

</Note>

## Understanding the @provides directive

The `@provides` directive is a federation routing optimization that reduces the number of subgraph calls needed to resolve queries. It enables a subgraph to resolve fields normally owned by another subgraph at specific query paths.

The `@provides` directive is a query planning optimization signal, not a data synchronization mechanism. It tells the Apollo Router that a field can be resolved by a different subgraph at a specific query path, enabling the router to reduce network round trips.

The `@provides` directive creates a relationship between two subgraphs:

- **The source of truth subgraph** owns the field and can always resolve it.
- **The provider subgraph** uses `@provides` to return the same data more efficiently at specific query paths.

Both subgraphs must resolve the field identically to ensure data consistency. Ensure each subgraph's resolver behaves identically for that field. Otherwise, queries might return inconsistent results to your users depending on which subgraph resolves the field.

The `@provides` directive is a performance optimization that doesn't change the logic or behavior of your queries. Any query using `@provides` must work correctly without it. This directive only improves performance and doesn't change the logical behavior of your GraphQL operations.

Apollo recommends using `@provides` to reduce the number of subgraphs your router communicates with to resolve operations.

## Use cases

Use the `@provides` directive for:

- **Search optimization**: When a search subgraph (e.g., backed by Elasticsearch) needs to return fields normally owned by another subgraph to avoid additional round trips
- **Read-only computed fields**: Fields that derive their value from other fields and have no side effects, where the providing subgraph can compute them identically
- **Optimized data stores**: When using specialized stores (such as Elasticsearch or Redis) that contain a subset of data from the source of truth, and you want to reduce subgraph calls for specific query paths.
- **Performance-critical queries**: Queries that execute frequently and benefit from fewer subgraph calls.
- **Data retention scenarios**: When the providing subgraph has limited data retention (e.g., last 30 days) but the query scope matches that retention period

## Syntax

<Note>

For basic `@provides` syntax, see the [directive reference](/graphos/schema-design/federated-schemas/reference/directives#provides). The following sections cover advanced syntax patterns and best practices.

</Note>

### Providing multiple fields

You can provide multiple fields in a single `@provides` directive:

```graphql
# Source of truth subgraph
type Product @key(fields: "id") {
  id: ID!
  name: String! @shareable
  price: Float! @shareable
}

# Providing subgraph
type Product @key(fields: "id") {
  id: ID!
  name: String! @external
  price: Float! @external
}

type Query {
  searchProducts(query: String!): [Product!]!  @provides(fields: "name price")
}
```

### Providing fields from a subgraph

You can provide the value of nested fields in the `@provides` directive:

```graphql
# Source of truth subgraph
type Product @key(fields: "id") {
  id: ID!
  name: String! @shareable

}

# Providing subgraph
type Product @key(fields: "id") {
  id: ID!
  name: String! @external
}

type SearchProductsEdge {
  node: Product!
}

type SearchProductsConnection {
  edges: [SearchProductsEdge!]!
}

type Query {
  searchProducts(query: String!): SearchResult @provides(fields: "edges { node { name } }")
}
```

### Consistency requirement

If a field is provided using `@provides`, it must be marked as `@shareable` in at least one other subgraph (the source of truth):

```graphql
# Products subgraph (source of truth)
type Product @key(fields: "id") {
  id: ID!
  price: Float! @shareable  # Must be @shareable
}

# Search subgraph (providing subgraph)
type Product @key(fields: "id") {
  id: ID! @external
  price: Float! @external  # Marked as @external
}

type SearchResult {
  products: [Product!]! @provides(fields: "price")
}
```

## When to use @provides

Use `@provides` when all of the following conditions are met:

✅ The query already works without it

The query must already work correctly without `@provides`. The directive only improves performance; it doesn't change the logical behavior of your GraphQL operations.

✅ Identical data

The provided data must match the source data. Both subgraphs must resolve the field identically to ensure data consistency.

✅ Performance optimization

Use `@provides` to achieve a specific performance optimization goal: reducing the number of subgraph calls for a query. Apply it strategically instead of only in case you might need it.

✅ Query path-specific

The optimization is scoped to a specific query path. Apply `@provides` to fields that return entities instead of to entity fields themselves.

✅ Data consistency maintained

Maintain data consistency (including data retention and eventual consistency considerations) between the source of truth and the providing subgraph.

✅ Privacy and security compliance

Ensure that storing and accessing the provided data in the providing subgraph's storage system complies with your organization's privacy and security requirements.

## When not to use @provides

### Fixing slow subgraph performance

The `@provides` directive is a federation routing optimization, not a solution for subgraph performance issues. If a subgraph experiences performance problems, such as slow queries or database bottlenecks, `@provides` doesn't solve those issues. The directive only optimizes how the router distributes queries across subgraphs by reducing the number of subgraph calls, but it doesn't make individual subgraphs faster.

```graphql
# ❌ BAD: Using @provides to work around slow subgraph
# This hides the underlying performance problem
type SearchResult {
  products: [Product!]! @provides(fields: "price")
}
```

Better approach: Address performance at the subgraph level (database optimization, caching, query tuning, and others), not with `@provides`.

### To introduce logical differences

Don't use `@provides` to introduce logical differences or alternate data sources. The provided data must match the source data exactly.

```graphql
# ❌ BAD: Providing different data from source
# Search subgraph returns discounted price, Products returns regular price
type SearchResult {
  products: [Product!]! @provides(fields: "price")  # Different logic!
}
```

### When data divergence is possible

If there's any possibility of data divergence, don't use `@provides`. This includes scenarios where:
- Data retention policies differ significantly and can't be mitigated through query scope
- Eventual consistency delays are unacceptable for your use case
- Different subgraphs might resolve the field differently.

❌ Avoid mutable fields

Avoid `@provides` on fields that you frequently mutate, because synchronization delays can cause data inconsistencies.

### User-specific or context-dependent data

Fields whose values depend on the requesting user or context shouldn't use `@provides`, because different subgraphs might have different context.

```graphql
# ❌ BAD: Price might be user-specific
type Product @key(fields: "id") {
  id: ID!
  price: Float! @shareable  # Personalized pricing
}

# Search subgraph can't provide personalized price
type SearchResult {
  products: [Product!]! @provides(fields: "price")  # Wrong price!
}
```

### To paper over data inconsistencies

Never use `@provides` to hide the fact that two subgraphs have conflicting data. Fix the data at the source.

```graphql
# ❌ BAD: Using @provides to hide data conflicts
# Products subgraph returns price: 99.99
# Search subgraph returns price: 89.99
type SearchResult {
  products: [Product!]! @provides(fields: "price")  # Masking problem!
}
```

### For sensitive data without compliance

Don't use `@provides` for sensitive data (PII, financial information, and others) unless the providing subgraph's storage system is approved and compliant with all relevant regulations.

## Interacting with other directives

Learn how `@provides` interacts with other Federation directives.

### Using @shareable

If you provide a field using `@provides`, mark it as `@shareable` in at least one other subgraph (the source of truth):

```graphql
# Products subgraph (source of truth)
type Product @key(fields: "id") {
  id: ID!
  price: Float! @shareable  # Must be @shareable
}

# Search subgraph (providing subgraph)
type Product @key(fields: "id") {
  id: ID! @external
  price: Float! @external
}

type SearchResult {
  products: [Product!]! @provides(fields: "price")
}
```

The field must be marked as `@shareable` first before it can be provided by another subgraph.

### With @external

Mark provided fields as `@external` in the providing subgraph:

```graphql
# Search subgraph
type Product @key(fields: "id") {
  id: ID! @external
  price: Float! @external  # Must be @external
}

type SearchResult {
  products: [Product!]! @provides(fields: "price")
}
```

The `@external` directive indicates that the subgraph usually can't resolve the field, but it needs to define it for `@provides` purposes.

### With @key

Use `@provides` on fields that return entities identified by `@key`:

```graphql
type Product @key(fields: "id") {
  id: ID!
  price: Float! @shareable
}

type SearchResult {
  products: [Product!]! @provides(fields: "price")  # Product is keyed by id
}
```

### With @requires

`@provides` and `@requires` serve different purposes:
- `@provides`: A subgraph provides fields it doesn't own.
- `@requires`: A subgraph requires fields it doesn't own to resolve other fields.

Both directives use `@external` to mark fields they don't own.

### Composition rules

If a subgraph `@provides` an entity field:

- The subgraph must define that field and mark it as `@external`
- The entity field must be marked as either `@shareable` or `@external` in every subgraph that defines it
- The entity field must be marked as `@shareable` in at least one other subgraph (for example, there's at least one subgraph that can always resolve the field)

Violating any of these rules causes composition to fail.

## Router behavior and query planning

### Understand how the router uses @provides

When the router encounters a query that uses `@provides`, it analyzes the query plan to determine if it can satisfy the entire query from the providing subgraph, which eliminates the need to call the source of truth subgraph.

### Query planning process

1. **Detection**: The router detects that a field in the query path has `@provides` applied.
2. **Validation**: The router validates that the providing subgraph's schema matches the source of truth subgraph's schema for the provided fields.
3. **Optimization**: If the provided fields cover all fields needed for the query, the router makes a single call to the providing subgraph instead of multiple calls.
4. **Fallback**: If the provided fields don't cover all needed fields, the router falls back to the original plan and calls both subgraphs.

### Performance impacts

Without @provides:

```graphql
query {
  searchProducts(query: "laptop") {
    products {
      id      # From Search subgraph
      name    # From Search subgraph
      price   # From Products subgraph (separate call)
    }
  }
}
```

Query plan: 2 subgraph calls
- Call 1: Search subgraph (id, name)
- Call 2: Products subgraph (price)

### Use @provides

```graphql
query {
  searchProducts(query: "laptop") {
    products {
      id      # From Search subgraph
      name    # From Search subgraph
      price   # From Search subgraph (provided)
    }
  }
}
```

Query plan: 1 subgraph call
- Call 1: Search subgraph (id, name, price)

Performance benefit: Reduced latency, fewer network round trips, reduced overall query time.

### Ensure complete field coverage

If the router still needs to call the source subgraph because your `@provides` directive doesn't cover all fields needed for a query, you lose the performance optimization. Because you're making the original call anyway, `@provides` provides no benefit.

### Example of failed optimization

```graphql
# Query requests: id, name, price, description
# @provides only covers: price
# Result: Router still calls Products for id, name, description
# Optimization: FAILED (no benefit)
```

### Example of successful optimization

```graphql
# Query requests: id, name, price
# @provides covers: id, name, price
# Result: Router only calls Search subgraph
# Optimization: SUCCESS (1 call instead of 2)
```

### Query planning complexity

`@provides` adds complexity to query planning, but it's more straightforward than `@shareable` because:

- `@provides` is scoped to specific query paths instead of being global like `@shareable`
- The router evaluates whether the provided fields cover the query's requirements
- If coverage is complete, the router applies the optimization; otherwise, it falls back

### Best practices for performance

- Be selective: Use `@provides` only when there's a clear performance benefit
- Ensure complete coverage: Provide all fields required for the query
- Monitor query performance: Use Apollo Studio to track query execution times.
- Measure performance: Profile query performance before and after you add `@provides`

## Example use cases

### Search optimization with complete coverage

```graphql
# Products subgraph (source of truth)
extend schema
  @link(url: "https://specs.apollo.dev/federation/v2.3",
        import: ["@key", "@shareable"])

type Product @key(fields: "id") {
  id: ID!
  name: String! @shareable
  price: Float! @shareable
}

# Search subgraph (providing subgraph)
extend schema
  @link(url: "https://specs.apollo.dev/federation/v2.3",
        import: ["@key", "@external", "@provides"])

type Product @key(fields: "id") {
  id: ID! @external
  name: String! @external
  price: Float! @external
}

type SearchResult {
  products: [Product!]! @provides(fields: "id name price")
}

type Query {
  searchProducts(query: String!): SearchResult
}
```

Why this works: The query typically requests `{ id, name, price }`, and `@provides` covers all three fields. The router can satisfy the entire query from the Search subgraph, eliminating the need to call Products.

### Data retention with documented scope

```graphql
# Products subgraph (source of truth - all historical data)
extend schema
  @link(url: "https://specs.apollo.dev/federation/v2.3",
        import: ["@key", "@shareable"])

type Product @key(fields: "id") {
  id: ID!
  name: String!
  price: Float! @shareable
}

# Search subgraph (providing subgraph)
extend schema
  @link(url: "https://specs.apollo.dev/federation/v2.3",
        import: ["@key", "@external", "@provides"])

type Product @key(fields: "id", resolvable: false) {
  id: ID!
  name: String!
  price: Float! @external
}

type Query {
  """Searches for products added in the last 30 days"""
  searchRecentProducts(query: String!): [Product!]! @provides(fields: "price")
}
```

Why this works: The query only searches products from the last 30 days, and Elasticsearch retains 30+ days of data. The query path itself limits the scope, making `@provides` valid even though overall retention differs.

### Privacy-aware field selection

```graphql
# Users subgraph (source of truth)
extend schema
  @link(url: "https://specs.apollo.dev/federation/v2.3",
        import: ["@key", "@shareable"])

type User @key(fields: "id") {
  id: ID!
  username: String! @shareable
  displayName: String! @shareable
  email: String!
  phoneNumber: String!
  ssn: String!
}

# Search subgraph
extend schema
  @link(url: "https://specs.apollo.dev/federation/v2.3",
        import: ["@key", "@external", "@provides"])

type User @key(fields: "id") {
  id: ID! @external
  username: String! @external
  displayName: String! @external
  # email, phoneNumber, ssn are NOT provided
}

type SearchResult {
  users: [User!]! @provides(fields: "username displayName")
}

type Query {
  searchUsers(query: String!): SearchResult
}
```

Why this works: Only non-sensitive fields are provided. Sensitive fields (`email`, `phoneNumber`, `ssn`) remain in the Users subgraph even though Elasticsearch might have access to them, ensuring compliance with privacy and security requirements.

### Incomplete field coverage

```graphql
# Query requests: id, name, price
# But @provides only covers: price

type SearchResult {
  products: [Product!]! @provides(fields: "price")  # ❌ Missing id and name
}

type Query {
  searchProducts(query: String!): SearchResult
}
```

Why this fails: The router still needs to call Products for `id` and `name`, losing the optimization. The performance benefit is lost.

Better approach: Provide all fields needed for the query:

```graphql
type SearchResult {
  products: [Product!]! @provides(fields: "id name price")  # ✅ Complete coverage
}
```

### Providing more than needed

```graphql
# Query only requests: id, name, price
# But @provides covers: id, name, price, description, category, reviews

type SearchResult {
  products: [Product!]! @provides(fields: "id name price description category reviews")  # ❌ Too much
}
```

Why this fails: Providing extra fields adds complexity and management overhead without performance benefit. The optimization works, but you're maintaining more than necessary.

Better approach: Provide exactly what's needed:

```graphql
type SearchResult {
  products: [Product!]! @provides(fields: "id name price")  # ✅ Minimal set
}
```

### Using @provides to hide performance issues

```graphql
# Products subgraph is slow, so @provides is used to bypass it
type SearchResult {
  products: [Product!]! @provides(fields: "price")  # ❌ Hiding problem
}
```

Why this fails: This hides the underlying performance problem. The slow subgraph will still be slow, and you've added complexity without solving the root cause.

Better approach: Fix performance at the subgraph level (database optimization, caching, query tuning, and others), not with `@provides`.

## Composition rules and migration

### Understand composition rules

Follow these composition rules if a subgraph `@provides` an entity field:

- The subgraph must define that field and mark it as `@external`
- The entity field must be marked as either `@shareable` or `@external` in every subgraph that defines it
- The entity field must be marked as `@shareable` in at least one other subgraph (for example, there's at least one subgraph that can always resolve the field)

Violating any of these rules causes composition to fail.

### Add @provides to existing queries

Follow these steps when you add `@provides` to an existing query:

1. **Mark the field as `@shareable`** in the source-of-truth subgraph first
2. **Mark the field as `@external`** in the providing subgraph
3. **Add @provides** to the field that returns the entity.
4. **Verify data consistency**: Ensure data is identical across both subgraphs
5. **Test the query** - confirm it works correctly without `@provides` first.
6. **Monitor performance** - Verify the optimization works as expected

### Remove @provides

Remove `@provides` from a query:

1. **Remove `@provides`** from the providing subgraph
2. **Keep @external** if the field is still needed for other purposes (for example, `@requires`)
3. **Publish your schemas** and verify composition
4. **Monitor queries**: Confirm they still work correctly because queries must work without `@provides`.

### Maintaining data consistency

Although composition rules ensure your schema is valid, they don't guarantee that your data is consistent. You are responsible for maintaining data consistency.

Data retention: When you use `@provides`, the providing subgraph and the source of truth subgraph might have different data retention policies. This is acceptable as long as the providing subgraph has all the data needed for the queries that use `@provides`. Document the query's scope clearly.

Eventual consistency: When you use `@provides`, account for eventual consistency. This is the time delay between when data is updated in the source of truth and when it's synchronized to the providing subgraph. Only use `@provides` when eventual consistency is acceptable for your use case.

## Troubleshooting and FAQ

### Why isn't my optimization working? The router still calls both subgraphs

A: Your `@provides` directive might not cover all fields required for the query. If the router must call the source subgraph for any fields, you lose the performance optimization.

### Resolve optimization issues

- Analyze the specific query path you're optimizing.
- Ensure `@provides` covers all fields requested in the query.
- Use Apollo Studio to inspect the query plan and see which subgraphs Apollo calls

### Troubleshooting composition failures

Check that you followed all composition rules:

- Mark the field as `@external` in the providing subgraph
- Mark the field as `@shareable` in at least one other subgraph (the source of truth)
- Mark the field as either `@shareable` or `@external` in every subgraph that defines it

### Resolve the error

- Verify the source of truth subgraph includes `@shareable` on the field
- Verify the providing subgraph marks the field as `@external`
- Ensure all subgraphs that define the field mark it as `@shareable` or `@external`

### Troubleshoot inconsistent data

This behavior violates the core assumption of `@provides`: that fields contain identical data across both subgraphs. The router doesn't guarantee which subgraph it queries, so inconsistencies cause non-deterministic behavior.

### Fix data inconsistencies

- Fix data consistency at the source.
- Verify both subgraphs return identical values for the provided field.
- Check for eventual consistency issues, such as synchronization delays
- Ensure data retention policies are compatible with query scope.

### Can I use @provides on entity fields directly?

No. Apply `@provides` to fields that return entities (such as `products: [Product!]!`), instead of to entity fields themselves. The directive specifies which fields of the returned entity the subgraph can provide.

```graphql
# ✅ CORRECT: @provides on field returning entity
type SearchResult {
  products: [Product!]! @provides(fields: "price")
}

# ❌ INCORRECT: @provides on entity field
type Product @key(fields: "id") {
  price: Float! @provides(fields: "price")  # Not allowed
}
```

### Do I need @shareable if I'm using @provides?

Yes. The field must be marked as `@shareable` in at least one other subgraph (the source of truth) before it can be provided. `@provides` requires `@shareable` as a prerequisite.

### What happens if I don't mark a field as @shareable in the source of truth?

Composition fails with an error. You must mark the field as `@shareable` in at least one subgraph (the source of truth) for `@provides` to work.

### How can I tell if @provides improves performance?

Monitor these metrics in Apollo Studio:

- Query execution time (end-to-end latency).
- Subgraph calls per query
- Subgraph request distribution
- Query plan details

Monitor these metrics:

- Fewer subgraph calls
- Reduced query execution time
- Queries satisfied by the providing subgraph alone

### Should I use @provides for "future flexibility"?

No. Only use `@provides` when you have:

- A specific performance optimization goal.
- Fields with identical data across subgraphs
- A query that currently makes multiple subgraph calls

Only use `@provides` when you have a specific performance optimization goal.

### Can I use @provides with @requires?

Yes, but they serve different purposes:

- `@provides`: A subgraph provides fields it doesn't own.
- `@requires`: A subgraph requires fields it doesn't own to resolve other fields

Both directives use `@external` to mark fields they don't own, but they apply to different scenarios.

### What if my providing subgraph has different data retention than the source?

This is acceptable as long as the providing subgraph has all the data needed for the queries that use `@provides`. Document the query's scope clearly (for example, "searches products from the last 30 days"), and ensure the providing subgraph covers that scope.

## Summary Checklist

### Before you use @provides

- [ ] The query already works correctly without `@provides`.
- [ ] The field returns identical data in both subgraphs.
- [ ] You have a specific performance optimization goal
- [ ] Mark the field as `@shareable` in the source of truth subgraph
- [ ] Mark the field as `@external` in the providing subgraph
- [ ] Verify data consistency (including retention and eventual consistency)
- [ ] Your providing subgraph's storage system complies with privacy and security requirements
- [ ] The `@provides` directive covers all fields needed for the query

### Apply @provides

- [ ] Mark as `@shareable` in the source of truth subgraph
- [ ] Mark as `@external` in the providing subgraph
- [ ] Verify data consistency across both implementations
- [ ] Test the query to verify it works without `@provides` first
- [ ] Monitor query performance in Apollo Studio
- [ ] Document why this field is provided for future maintainers
- [ ] Verify the optimization works (reduced subgraph calls)

### Identify when to remove @provides

- [ ] The field returns different data in multiple subgraphs
- [ ] The query doesn't work correctly without the `@provides` directive
- [ ] The optimization doesn't work (the router still calls both subgraphs)
- [ ] You cannot maintain data consistency
- [ ] Privacy or security requirements are not met
- [ ] You can't explain why this field needs to be provided
- [ ] I use `@provides` to hide a performance problem in a subgraph

## References

- [`@provides` directive reference](https://www.apollographql.com/docs/graphos/schema-design/federated-schemas/reference/directives#provides)
- [Apollo Federation @shareable Directive Reference](https://www.apollographql.com/docs/graphos/schema-design/federated-schemas/reference/directives#shareable)
- [Apollo Federation @external Directive](https://www.apollographql.com/docs/graphos/schema-design/federated-schemas/reference/directives#external)
- [Resolve another subgraph's fields](https://www.apollographql.com/docs/graphos/schema-design/federated-schemas/entities/resolve-another-subgraphs-fields)
- [Query planning best practices](https://www.apollographql.com/docs/graphos/federation/query-planning)

---

Document version: v1.0  
Last updated: 2025  
Federation version: Apollo Federation v2.3.0 or later
