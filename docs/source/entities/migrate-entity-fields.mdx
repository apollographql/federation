import ProgressiveOverrideEnterprise from '../shared/progressive-override-enterprise.mdx';

## Migrating entity fields and root fields

As your supergraph grows, you might want to move parts of one subgraph to another subgraph. This section describes how to migrate entity and root fields safely.

### Using the `@override` directive

You can migrate between subgraphs all at once with `@override`.

<Tip>

We recommend organizations with an Enterprise license to migrate gradually with progressive `@override`. See the guide [Incremental migration with progressive `@override`](#incremental-migration-with-progressive-override).

</Tip>

Let's say the Payments subgraph defines a `Bill` entity:

<CodeColumns>

```graphql title="Payments subgraph"
type Bill @key(fields: "id") {
  id: ID!
  amount: Int!
  payment: Payment
}

type Payment {
  # ...
}
```

</CodeColumns>

As your graph evolves, you decide to add a dedicated Billing subgraph to your supergraph. It makes sense to move billing functionality there, including the amount of a bill. You want the deployed subgraph schemas to look like this:

<CodeColumns>

```graphql title="Payments subgraph"
type Bill @key(fields: "id") {
  id: ID!
  payment: Payment
}

type Payment {
  # ...
}
```

```graphql title="Billing subgraph"
type Bill @key(fields: "id") {
  id: ID!
  amount: Int!
}
```

</CodeColumns>

The [`@override` directive](./federated-types/federated-directives#override) enables you to incrementally migrate between subgraphs with no downtime.

Follow these steps to use the `@override` directive:

1. If the `@override` directive isn't already imported, include it in your schema's `@link` imports:

    ```graphql {3} title="Billing subgraph"
    extend schema
      @link(url: "https://specs.apollo.dev/federation/v2.7",
            import: ["@key", "@shareable", "@override"])
    ```

2. Deploy a new version of the Billing subgraph that both defines and resolves the `Bill` fields you want to move:

    <CodeColumns>

      ```graphql title="Payments subgraph"
      type Bill @key(fields: "id") {
        id: ID!
        amount: Int!
        payment: Payment
      }

      type Payment {
        # ...
      }
      ```

      ```graphql {3} title="Billing subgraph"
      type Bill @key(fields: "id") {
        id: ID!
        amount: Int! @override(from: "Payments") #highlight-line
      }
      ```

    </CodeColumns>

      Applying the `@override` directive tells the router to resolve the `amount` field in the Billing subgraph instead of the Payments subgraph.


3. Update your router's supergraph schema to migrate to the updated Billing subgraph. If you're using managed federation, you do this by publishing the Billing subgraph's schema to GraphOS with [`rover subgraph publish`](/graphos/delivery/#subgraph-schemas).

When the router receives its updated supergraph schema, it immediately starts resolving the `Bill.amount` field from the Billing subgraph while continuing to resolve `Bill.payment` from the Payments subgraph.

<Note>

We can migrate as many entity fields as we want in a single change. To do so, we apply `@override` to every entity field we want to move. We can even migrate entire entities this way.

</Note>

Now that `Bill.amount` is resolved in the Billing subgraph, we can safely remove that field (and its resolver) from the Payments subgraph:

<CodeColumns>

  ```graphql {1-4} title="Payments subgraph"
  type Bill @key(fields: "id") {
    id: ID!
    payment: Payment
  }

  type Payment {
    # ...
  }
  ```

  ```graphql title="Billing subgraph"
  type Bill @key(fields: "id") {
    id: ID!
    amount: Int! @override(from: "Payments")
  }
  ```

</CodeColumns>

After making this change, we deploy our updated Payments subgraph and again update our router's supergraph schema.

<Note>

Because the router is already ignoring `Bill.amount` in the Payments subgraph thanks to `@override`, we can safely publish our updated schema or deploy the subgraph in any order.

</Note>

4. Remove the `@override` directive from the Billing subgraph, because it no longer has any effect:

    <CodeColumns>

      ```graphql title="Payments subgraph"
      type Bill @key(fields: "id") {
        id: ID!
        payment: Payment
      }

      type Payment {
        # ...
      }
      ```

      ```graphql {3} title="Billing subgraph"
      type Bill @key(fields: "id") {
        id: ID!
        amount: Int!
      }
      ```
    </CodeColumns>

After we deploy the Billing subgraph and publish this final schema change, we're done. We've migrated `Bill.amount` to the Billing subgraph with zero downtime.

<MinVersion version="2.7">

### Incremental migration with progressive `@override`

</MinVersion>

You can migrate between subgraphs gradually with progressive `@override`.

<ProgressiveOverrideEnterprise/>

Let's say the Payments subgraph defines a `Bill` entity:

<CodeColumns>

```graphql title="Payments subgraph"
type Bill @key(fields: "id") {
  id: ID!
  amount: Int!
  payment: Payment
}

type Payment {
  # ...
}
```

</CodeColumns>

As your graph evolves, you decide to add a dedicated Billing subgraph to your supergraph. It makes sense to move billing functionality there, including the amount of a bill. You want the deployed subgraph schemas to look like this:

<CodeColumns>

```graphql title="Payments subgraph"
type Bill @key(fields: "id") {
  id: ID!
  payment: Payment
}

type Payment {
  # ...
}
```

```graphql title="Billing subgraph"
type Bill @key(fields: "id") {
  id: ID!
  amount: Int!
}
```

</CodeColumns>

The [`@override` directive](./federated-types/federated-directives#override) enables you to incrementally migrate between subgraphs with no downtime.

Follow these steps to use the `@override` directive:

1. If the `@override` directive isn't already imported, include it in your schema's `@link` imports:

    ```graphql {3} title="Billing subgraph"
    extend schema
      @link(url: "https://specs.apollo.dev/federation/v2.7",
            import: ["@key", "@shareable", "@override"])
    ```

2. Deploy a new version of the Billing subgraph that both defines and resolves the `Bill` fields you want to move:

    <CodeColumns>

      ```graphql title="Payments subgraph"
      type Bill @key(fields: "id") {
        id: ID!
        amount: Int!
        payment: Payment
      }

      type Payment {
        # ...
      }
      ```

      ```graphql {3} title="Billing subgraph"
      type Bill @key(fields: "id") {
        id: ID!
        amount: Int! @override(from: "Payments", label: "percent(1)") #highlight-line
      }
      ```

    </CodeColumns>

      Applying the `@override` directive tells the router to resolve the `amount` field in the Billing subgraph instead of the Payments subgraph. 

      Adding a `label` argument to the `@override` directive sets the percentage of traffic to direct to the Billing subgraph. Start with a small percentage. Setting `label: "percent(1)"` means that 1 percent of the requests for `amount` are resolved by the Billing subgraph, while the remaining 99 percent are resolved by the Payments subgraph. 

3. Update your router's supergraph schema to begin the migration to the updated Billing subgraph.

When the router receives its updated supergraph schema, it starts resolving the `Bill.amount` field from the Billing subgraph approximately 1% of the time, while continuing to resolve it from the Payments subgraph the other 99%.

<Note>

We can migrate as many entity fields as we want in a single change. To do so, we apply `@override` to every entity field we want to move. We can even migrate entire entities this way.

</Note>

4. Gradually and iteratively increase the percent of traffic directed to the Billing subgraph, update your router's supergraph schema, and validate the performance of the Billing subgraph. Continue until the migration is completed with `label: "percent(100)"` and all traffic is resolved by the Billing subgraph.

    ```graphql title="Billing subgraph"
    type Bill @key(fields: "id") {
      id: ID!
      amount: Int! @override(from: "Payments", label: "percent(100)") #highlight-line
    }
      ``` 

5. Now that `Bill.amount` is resolved in the Billing subgraph, we can safely remove that field (and its resolver) from the Payments subgraph:

<CodeColumns>

  ```graphql {1-4} title="Payments subgraph"
  type Bill @key(fields: "id") {
    id: ID!
    payment: Payment
  }

  type Payment {
    # ...
  }
  ```

  ```graphql title="Billing subgraph"
  type Bill @key(fields: "id") {
    id: ID!
    amount: Int! @override(from: "Payments")
  }
  ```

</CodeColumns>

After making this change, we deploy our updated Payments subgraph and again update our router's supergraph schema.

<Note>

Because the router is already ignoring `Bill.amount` in the Payments subgraph thanks to `@override`, we can safely publish our updated schema and deploy the subgraph in any order.

</Note>

6. Remove the `@override` directive from the Billing subgraph because it no longer has any effect:

    <CodeColumns>

      ```graphql title="Payments subgraph"
      type Bill @key(fields: "id") {
        id: ID!
        payment: Payment
      }

      type Payment {
        # ...
      }
      ```

      ```graphql {3} title="Billing subgraph"
      type Bill @key(fields: "id") {
        id: ID!
        amount: Int!
      }
      ```
    </CodeColumns>

After we deploy the Billing subgraph and publish this final schema change, we're done. We've migrated `Bill.amount` to the Billing subgraph with zero downtime.

#### Safe usage of progressive `@override`

When using progressive `@override`, a single operation can now result in multiple query plans. Query plans are cached by the router, with the set of unique, overridden labels contributing to the cache key. 

Prior to progressive `@override`, only a single query plan was generated for a given operation. With progressive `@override`, the number of query plans doubles for each unique label in the operation's "path". 

A few strategies to mitigate this concern:

1. Don't leave progressive `@override` in place indefinitely. Migrate the field and remove the `label` argument from the `@override` directive as soon as reasonably possible.
2. Share labels across fields that are being migrated together. For example, if you are migrating `Bill.amount` and `Bill.payment` together, use the same label for both fields. This will ensure that the number of query plans does not increase as a result of the migration.
3. Use a small, known set of labels (for example `percent(5)`, `percent(25)`, `percent(50)`).

#### Customizing progressive `@override` behavior with a feature flag service

Out of the box, the router supports the `percent(x)` syntax for resolving labels based on a given percentage. Unfortunately, updating this number requires a subgraph publish and router redeploy. To avoid this, you can use a feature flag service to dynamically update the label value.

The router provides an interface for coprocessors and rhai scripts to resolve arbitrary labels. This allows you to dial up or disable a label's rollout status without requiring a subgraph publish. A coprocessor or rhai script that implements this should take the following steps:
1. Implement the [`SupergraphService`](/router/customizations/rhai/#supergraphservice)
2. Inspect the `apollo_override::unresolved_labels` context key to determine which labels exist in the schema that haven't been resolved by the router.
3. Resolve the labels using your feature flag service (or any other mechanism).
4. Add the resolved labels to the `apollo_override::labels_to_override` context key.

<Note>

The unresolved labels are all labels in the schema that haven't been resolved by the router. They may not all pertain to the incoming operation. As a final step, the router will filter the resolved labels to only those that are relevant to the operation in order to minimize the set of labels contributing to the query plan cache key. It is expected that a coprocessor or rhai script will resolve all labels in the schema, not just those relevant to the operation.

</Note>

For an example implementation of a coprocessor that resolves labels using LaunchDarkly, see [the example](https://github.com/apollographql/router/tree/main/examples/coprocessor-override-launchdarkly/README.md) in the router repo.

### Optimizing for fewer deploys with manual composition

<Caution>

This method requires careful coordination between subgraph and router updates. Without strict control over the order of deployments and schema updates, you might cause an outage. For most use cases, we recommend using the [`@override` method above](#incremental-migration-with-override).

</Caution>

Using `@override` to migrate entity fields enables us to migrate fields incrementally with zero downtime. However, doing so requires three separate schema publishes. If you're using [manual composition](./federated-types/composition#manually-with-the-rover-cli), each schema change requires redeploying your router. With careful coordination, we can perform the same migration with only a single router redeploy.

1. In the Billing subgraph, define the `Bill` entity, along with its corresponding resolvers. These new resolvers should behave identically to the Payment subgraph resolvers they're replacing.

    <CodeColumns>

      ```graphql title="Payments subgraph"
      type Bill @key(fields: "id") {
        id: ID!
        amount: Int!
        payment: Payment
      }

      type Payment {
        # ...
      }
      ```

      ```graphql title="Billing subgraph"
      type Bill @key(fields: "id") {
        id: ID!
        amount: Int!
      }
      ```

    </CodeColumns>

2. Deploy the updated Billing subgraph to your environment, but do not publish the updated schema yet.

    - At this point, the Billing subgraph can successfully resolve `Bill` objects, but the router doesn't know this yet because its supergraph schema hasn't been updated. Publishing the schema would cause a composition error.

3. In the Payments subgraph, remove the migrated fields from the `Bill` entity and their associated resolvers (do not deploy this change yet):

    <CodeColumns>

    ```graphql title="Payments subgraph"
    type Bill @key(fields: "id") {
      id: ID!
      payment: Payment
    }

    type Payment {
      # ...
    }
    ```

    ```graphql title="Billing subgraph"
    type Bill @key(fields: "id") {
      id: ID!
      amount: Int!
    }
    ```

    </CodeColumns>

4. Compose an updated supergraph schema with your usual configuration using `rover supergraph compose`.
    - This updated supergraph schema indicates that the Billing subgraph resolves `Bill.amount`, and the Payments subgraph doesn't.

5. Assuming CI completes successfully, deploy an updated version of your router with the new supergraph schema.
    - When this deployment completes, the router begins resolving `Bill` fields in the Billing subgraph instead of the Payments subgraph.

    - While your new router instances are deploying, you will probably have active router instances resolving the `Bill.amount` field in two different ways (with older instances still resolving it from Payments). It's important that the two subgraphs resolve the field in exactly the same way, or your clients might see inconsistent data during this rollover.

6. Deploy the updated version of your Payments subgraph without the migrated field.
    - At this point it's safe to remove this definition, because your router instances are using the Billing subgraph exclusively.

We're done! The migrated fields have been moved to a new subgraph, and we only  redeployed our router once.
